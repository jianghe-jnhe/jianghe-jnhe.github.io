{"meta":{"title":"Jnhe","subtitle":"","description":"","author":"Jnhe","url":"https://jianghe-jnhe.github.io","root":"/"},"pages":[],"posts":[{"title":"人工智能与机器学习","slug":"AIandmachinelearn","date":"2023-12-17T13:32:09.000Z","updated":"2023-12-18T14:38:01.987Z","comments":true,"path":"2023/12/17/AIandmachinelearn/","permalink":"https://jianghe-jnhe.github.io/2023/12/17/AIandmachinelearn/","excerpt":"","text":"实验笔记 第1章：感知器（第1次实验） 随机生成双月数据 使用感知机，对双月实验数据进行分类 第2章：线性回归模型）（第2次实验） 使用ML（正则最小二乘法），对双月实验数据进行分类 使用MAP（最大似然估计）， 对双月实验数据进行分类 对比第1次实验与本次实验，进行说明 第3章：the least-mean-square（第3次实验） 使用LMS（最小均方&#x2F;自适应），对双月实验数据进行分类 第4章：多重感知机 感知机与双月实验原理 略 生成双月数据 文件夹目录D:\\Python\\AIML\\Project01\\Generate_data下g_data.py 建立output_data文件夹用于存放生成的数据D:\\Python\\AIML\\Project01\\Generate_data\\output_data 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# file name: g_data.py# -*- coding: utf-8 -*-#生成半月数据import numpy as npimport matplotlib.pyplot as plt def halfmoon(rad, width, d, n_samp): &#x27;&#x27;&#x27;生成半月数据 @param rad: 半径 @param width: 宽度 @param d: 距离 @param n_samp: 数量 &#x27;&#x27;&#x27; if n_samp%2 != 0: n_samp += 1 data = np.zeros((3,n_samp)) aa = np.random.random((2,int(n_samp/2))) radius = (rad-width/2) + width*aa[0,:] theta = np.pi*aa[1,:] x = radius*np.cos(theta) y = radius*np.sin(theta) label = np.ones((1,len(x))) # label for Class 1 x1 = radius*np.cos(-theta) + rad y1 = radius*np.sin(-theta) - d label1= -1*np.ones((1,len(x1))) # label for Class 2 data[0,:]=np.concatenate([x,x1]) data[1,:]=np.concatenate([y,y1]) data[2,:]=np.concatenate([label,label1],axis=1) return data def halfmoon_shuffle(rad, width, d, n_samp): data = halfmoon(rad, width, d, n_samp) shuffle_seq = np.random.permutation(np.arange(n_samp)) data_shuffle = data[:,shuffle_seq] return data_shuffle if __name__ == &quot;__main__&quot;: dataNum = 1000 data = halfmoon(10,5,5,dataNum) pos_data = data[:,0: int(dataNum/2)] neg_data = data[:, int(dataNum/2):dataNum] np.savetxt(&#x27;./output_data/halfmoon.txt&#x27;, data.T,fmt=&#x27;%4f&#x27;,delimiter=&#x27;,&#x27;) plt.figure() plt.scatter(pos_data[0,:],pos_data[1,:],c=&quot;b&quot;,s=10) plt.scatter(neg_data[0,:],neg_data[1,:],c=&quot;r&quot;,s=10) plt.savefig(&#x27;./output_data/moon.png&#x27;) plt.show() 感知机分类 文件夹目录D:\\Python\\AIML\\Project01\\Classified_data 下c_data.py 建立output_data文件夹用于存放生成的分类结果D:\\Python\\AIML\\Project01\\Classified_data\\output 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# file name: c_data.py# -*- coding: utf-8 -*-#通过感知机分类半月数据import numpy as npimport matplotlib.pyplot as pltdef sgn(y): y[y &gt; 0] = 1 y[y &lt; 0] = -1 return yclass Perceptron(object): &#x27;&#x27;&#x27;单层感知机 &#x27;&#x27;&#x27; def __init__(self, shape): super(Perceptron, self).__init__() self.w = np.ones(shape) #weigth self.b = 1.5 #the bias self.activate_func = sgn def update(self,x,y,out,learning_rate): self.w += learning_rate * x.T * (y - out) def calclate(self, x): return self.activate_func(np.dot(self.w, x.T) + self.b) def loss_func(self, pre_y, gt_y): return (pre_y - gt_y) ** 2 def train(self, x, y, epochs, learning_rate): losses = [] for epoch in range(epochs): loss_tmp = [] for i in range(x.shape[0]): out = self.calclate(x[i]) loss_tmp.append(self.loss_func(out, y[i])) self.update(x[i], y[i], out, learning_rate) losses.append(sum(loss_tmp)/len(loss_tmp)) return losses def predict(self, x): out = self.calclate(x) return out def test(self, x,y): label = self.predict(x) gt_count = np.sum(label==y) wrong_count = np.sum(label!=y) return wrong_count/(wrong_count+gt_count),gt_count/(wrong_count+gt_count) def get_params(self): return &#123;&#x27;weight&#x27;:self.w, &#x27;bias&#x27;:self.b&#125; def draw(self): axis = [i for i in range(1000)] out = [self.w * i + self.b for i in axis] plt.plot(axis, out) plt.show()def load_data(file): x = [] y = [] with open(file, &#x27;r&#x27;) as f: lines = f.readlines() for line in lines: line = line.strip().split(&#x27;,&#x27;) x_item = [float(line[0]), float(line[1])] y_item = float(line[2]) x.append(x_item) y.append(y_item) return np.array(x), np.array(y)def split_data(x, y): train_x, test_x = x[:int(x.shape[0]*0.7)], x[int(x.shape[0]*0.7):] train_y, test_y = y[:int(y.shape[0]*0.7)], y[int(y.shape[0]*0.7):] return train_x, train_y, test_x, test_yif __name__ == &#x27;__main__&#x27;: #进行非线性数据的分类实验时，只需要将数据的间隔缩小保证二者重合即可 desc = &#x27;nonlinear&#x27; file = &#x27;../Generate_data/output_data/halfmoon.txt&#x27; x,y = load_data(file) train_x, train_y, test_x, test_y = split_data(x, y) neur = Perceptron((1,2)) losses = neur.train(train_x,train_y,100, 0.0001) err,acc = neur.test(test_x, test_y) print(&#x27;rate of error:&#x27;, err) print(&#x27;rate of accuracy:&#x27;, acc) #画损失曲线 axis = [i for i in range(len(losses))] plt.figure() plt.plot(axis, losses) plt.savefig(&#x27;./output/%s_mse_loss.png&#x27; % desc) #plt.show() #画决策面 x_aixs = x[:,0] y_aixs = x[:,1] neg_x_axis = x_aixs[y==-1] neg_y_axis = y_aixs[y==-1] pos_x_axis = x_aixs[y==1] pos_y_axis = y_aixs[y==1] #感知机的参数 params = neur.get_params() w = params[&#x27;weight&#x27;] b = params[&#x27;bias&#x27;] k = -1 * w[0][0] / w[0][1] b = -1 * b / w[0][1] divid_x = [i for i in range(-15,25)] divid_y = [k * i + b for i in divid_x] plt.figure() plt.plot(divid_x, divid_y, c=&#x27;r&#x27;) plt.scatter(neg_x_axis,neg_y_axis,c=&quot;b&quot;,s=10) plt.scatter(pos_x_axis,pos_y_axis,c=&quot;g&quot;,s=10) plt.savefig(&#x27;./output/%s_divide.png&#x27; % desc) #保存决策面 参考教程 感知器及双月实验_双月分类 ML和MAP与双月实验 待完成ing LMS与双月实验 待完成ing","categories":[],"tags":[]},{"title":"资料指南","slug":"Whoami","date":"2023-12-10T02:09:22.000Z","updated":"2023-12-18T14:28:21.625Z","comments":true,"path":"2023/12/10/Whoami/","permalink":"https://jianghe-jnhe.github.io/2023/12/10/Whoami/","excerpt":"","text":"学习经历2019级本科生：通信工程 2021年09月，通过网上找资料和修改引脚完成课程设计：《基于51单片机的倒车雷达系统设计》，制作视频教程与演示视频，上传B站。 2022年02月，在倒车雷达基础上，增加蓝牙遥控小车。制作视频教程、演示视频及资料分享，详见视频简介处，视频已上传B站。 2022年05月，通信工程综合实训，学习《基于ESP8266的物联网智能家居控制》软件开发。 2022年06月，参考网上开源项目，完成《基于ESP8266的太空人时钟小电视》，软硬件及模型已全部免费分享。 2022年11月，基本完成本科毕业设计，《机械臂定点坐标控制系统设计》，参考资料与来源均在B站视频简介处标明。 2023年01月，毕业设计:《机械臂定点坐标控制》全部资料分享出来，资料使用指南视频已上传B站，Gitee开源链接详见视频简介处。 2023年05月，Gitee使用指南。以如何下载倒车雷达资料为例讲解。 2023年05月，机械臂完整教程已上传B站。 2023年07月，考研已结束，实习已结束，大学已毕业，开始商业合作接单。 2023级研究生：仪器科学与技术 2023年09月，第一次尝试与公司商业合作：讲述自己入门单片机的经历，并为其公司推广产品。 2023年10月，开始一边学习一边在实验室打螺丝。 2023年10月，完成接单：《基于STM32的智能衣架控制系统设计》。 2023年11月，完成接单：《基于STM32的智能语音控制系统设计》。 2023年12月，完成接单：《基于STM32的热控制搅拌杯系统设计》。 20xx年xx月，持续更新ing。 免费资料个人说明本人之前也是小白，什么都不懂，关于51的视频中有一些理解错的地方，请大家主动学习、自主思考，这样才能学到知识；如果不想思考，直接用我的板子就可以了，资料已经很详细并全部分享到Gitee了，没有必要加我要资料；只有需要我帮你做的，可以B站@姜河jnhe私信我，获取联系方式。 关于STM32的机械臂，其实没啥亮点和实际意义，很多算法其实也都有现成的库调用，而我自己写的代码很垃圾，对单片机的理解也不深入，所以大家仅作学习了解；如果仅是需要资料，认真读一下资料获取指南，免费下载用，不用找我要资料。我目前不打算走这个方向，所以不会维护和深入学习。 关于ESP8266的学习资料，我没有分享出来，原因：1.资料过大，且可以在网上找得到；2.开发方式不是Arduion，而是在Windows下使用eclipse，参考ESP8266 SDK开发的，配置很麻烦。我其实不懂，只是跟着技新课堂的视频教程改内容，接入物联网云平台，就算分享给大家，大家也用不了。 其他没有分享出来的，一般是因为那不是我的代码而且我不懂，例如51开发板驱动PCA9685控制机械臂，它来自51黑电子。 资料列表 Gitee下载资料教程 【视频版】https://www.bilibili.com/video/BV1xg4y1j7yb 【文字版】https://www.cnblogs.com/jianghe414/p/17367884.html 《基于51单片机的倒车雷达系统设计》 https://gitee.com/jianghe2022/astern-radar_v2.0 【Gitee下载，全部资料且详细】 https://pan.baidu.com/s/13pzx1tSyKKvMlToUTtk5yQ?pwd=hphu 【网盘下载，未来可能会被清理，下同】 《基于51单片机的蓝牙遥控小车设计》 https://pan.baidu.com/s/1ZiIHiyQp0tu6oA9e6seHmA?pwd=5akx 《基于ESP8266的太空人时钟小电视》 https://pan.baidu.com/s/1qcza0wGSEP7XAkdA8VbwXg?pwd=wcxb 《基于STM32的机械臂定点坐标控制系统设计》 https://gitee.com/jianghe2022/arm-rot_v0.1 商业接单主营业务 单片机毕设、课设软硬件功能实现，论文免费指导； 为公司或企业实现项目功能； 为公司产品做推广视频、科普视频等。 联系方式 B站@姜河jnhe，通过私信方式，加联系方式详谈 https://space.bilibili.com/496375938 随便唠唠RTOS买块成本可接受的开发板，跟着网上的教程学。 LinuxWindows电脑安装虚拟机，虚拟机中安装Linux Ubuntu，Ubuntu中安装QEMU，模拟Linux开发板，不花钱跟着网上的教程学。 免费博客依托Gitee或Github，安装一些前端的工具和HEXO，免费搭建一个属于自己的技术博客，记录和复习自己学的内容，打造自己的名片。","categories":[],"tags":[]},{"title":"初见博客","slug":"hello-world","date":"2023-12-04T05:40:39.955Z","updated":"2023-12-04T06:37:48.971Z","comments":true,"path":"2023/12/04/hello-world/","permalink":"https://jianghe-jnhe.github.io/2023/12/04/hello-world/","excerpt":"","text":"欢迎来到 Hexo！这是你的第一篇文章。查看文档了解更多信息。如果你在使用Hexo时遇到任何问题，你可以在故障排除中找到答案，或者你可以在GitHub上问我。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速入门 Quick Start创建一个新帖 Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing 运行网站服务 Run server1$ hexo server More info: Server 生成静态博客 Generate static files1$ hexo generate More info: Generating 部署到远程站点 Deploy to remote sites1$ hexo deploy More info: Deployment 参考教程文字版·基于Hexo的博客搭建：https://www.cnblogs.com/huanhao/p/hexobase.html视频版·基于Hexo的博客搭建：https://www.bilibili.com/video/BV1cW411A7Jx/","categories":[],"tags":[]}],"categories":[],"tags":[]}