{"meta":{"title":"Jnhe","subtitle":"","description":"","author":"Jnhe","url":"https://jianghe-jnhe.github.io","root":"/"},"pages":[],"posts":[{"title":"003-进程与线程","slug":"ProcessandThread","date":"2024-10-01T12:00:00.000Z","updated":"2024-10-01T13:24:45.616Z","comments":true,"path":"2024/10/01/ProcessandThread/","permalink":"https://jianghe-jnhe.github.io/2024/10/01/ProcessandThread/","excerpt":"","text":"基本概念 进程 process （Linux） 线程 thread （RT-Thread）&#x2F; 任务 task （FreeRTOS） 进程间通信 IPC （Interprocess Communication） 管道 pipe 进程间通信Linux 线程 管道 pipe 单向通信 有限缓冲区 阻塞读写 消息无类型 有序数据流 2个进程间 生产者-消费者模式 匿名管道 pipe 父-子进程间通信 命名管道 name pipe | FIFO 无亲缘关系进程间通信 消息队列 Queue 多个进程 异步通信-可非阻塞 有序发，可选择性收 持续存在 消息有类型 发布-订阅模式 链表 内存共享 Shared Memory 多个进程 无需操作系统内核-速度快 频繁传递大量数据 生产者-消费者模式 同步问题解决 信号量 semaphore 互斥锁 Mutex 类似 内存映射 Memory-mapped 文件系统 File System 套接字 Sockets 网络通信 不同主机进程间 应用于分布式系统 客户端-服务器模式 信号 Signal 软件中断 轻量级 异步 信号屏蔽-阻塞 观察者模式 | 状态机模式 线程间通信FreeRTOS RT-Tread Linux 同步与互斥 消息队列 Queue 任意类型消息 FIFO 信号量 Semaphore 解决同步问题 不存储资源 计数信号量：多线程&#x2F;任务 二值信号量：类似于互斥锁 互斥锁 Mutex 解决同步问题 阻塞（休眠） 事件组 Event Groups 解决复杂同步问题 允许任务等待 软件定时器 Timer 非阻塞 解决同步问题 通知 Notification FreeRTOS 轻量级 简单任务 效率高 邮箱 Mailbox RT-Tread 消息固定大小-类似消息队列 内存池 Memory Pool RT-Tread 内存块数据共享 效率高 条件变量 Condition Variable Linux 配合互斥锁 总结 通信方式 Linux FreeRTOS RT-Thread 消息队列 消息队列 消息队列 消息队列 邮箱 — — 邮箱 管道 管道 — 管道 共享内存 共享内存 — 内存池 信号量 信号量 信号量 信号量 互斥锁 互斥锁 互斥锁 互斥锁 条件变量 条件变量 — — 信号 信号 — 信号 通知 — 任务通知 — 事件 — 事件组 事件 中断 中断 中断 中断 软件定时器 软件定时器 软件定时器 软件定时器","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://jianghe-jnhe.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"002-字符与杂项","slug":"cdevandmisc","date":"2024-09-30T11:30:00.000Z","updated":"2024-09-30T13:52:15.836Z","comments":true,"path":"2024/09/30/cdevandmisc/","permalink":"https://jianghe-jnhe.github.io/2024/09/30/cdevandmisc/","excerpt":"","text":"基本概念 驱动 driver 开发（个人理解） 👇设备 device （&#x3D;&#x3D;对象&#x3D;&#x3D; objcet） 设备号（住址号）：区域 region ；（家庭住址，唯一性） 注册设备（属性（名字 name ）+行为&#x2F;操作 operations）：name | open relaase read write 👇设备节点 Node（&#x3D;&#x3D;类&#x3D;&#x3D; class） 👆内核kernel 有创建 create 就有销毁 destory 字符设备 字符&#x3D;&#x3D;设备号&#x3D;&#x3D;的申请 设备号类型 dev_t （无符号的 32 位整形类型 unsigned int ：高12位表示主设备号，低20位表示次设备号） 123456/* kernel/include/linux/types.h */typedef u32 __kernel_dev_t;typedef __kernel_dev_t dev_t;/* kernel/include/uapi/asm-generic/int-ll64.h */typedef unsigned int __u32; 1234567//API/* kernel/include/linux/kdev_t.h */#define MINORBITS 20 /* 次设备号位数 */#define MINORMASK ((1U &lt;&lt; MINORBITS) - 1) /* 次设备号掩码 */#define MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS)) /* dev右移20位得到主设备号 */#define MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK)) /* 与次设备掩码与，得到次设备号 */#define MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi)) /* MKDEV 宏将主设备号左移20位，然后与次设备号相与, 得到设备号*/ 静态申请 123/* kernel/include/linux/fs.h *///int register_chrdev_region(设备号, 设备数量, 设备名称)int register_chrdev_region(dev_t from, unsigned count, const char *name); 动态申请 123/* kernel/include/linux/fs.h *///int alloc_chrdev_region(设备号（数组形式）, 次设备号可申请最小值, 设备数量, 设备名称)int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) 字符&#x3D;&#x3D;设备&#x3D;&#x3D;的注册与注销 字符设备cdev 1234567891011/* kernel/include/linux/cdev.h */struct cdev &#123; struct kobject kobj; //内嵌的内核对象. struct module *owner; //该字符设备所在的内核模块的对象指针. const struct file_operations *ops; //该结构描述了字符设备所能实现的方法，是极为关键的一个结构体. struct list_head list; //用来将已经向内核注册的所有字符设备形成链表. dev_t dev; //字符设备的设备号，由主设备号和次设备号构成. unsigned int count; //隶属于同一主设备号的次设备号的个数.&#125;; 初始化 init 123/* kernel/include/linux/cdev.h *///void cdev_init(字符设备/结构体/对象, 操作/结构体/行为)void cdev_init(struct cdev *cdev, const struct file_operations *fops); 添加 add 123/* kernel/include/linux/cdev.h *///int cdev_add(字符设备/结构体/对象, 设备号, 设备数量)int cdev_add(struct cdev *p, dev_t dev, unsigned count) 删除 del 123/* kernel/include/linux/fs.h *///void cdev_del(字符设备/结构体/对象)void cdev_del(struct cdev *p) 字符设备的&#x3D;&#x3D;操作&#x3D;&#x3D; 文件操作集 file_operations 12345678/* kernel/include/linux/cdev.h */static struct file_operations cdev_fops_test = &#123; .owner = THIS_MODULE, //将 owner 字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块 .open = chrdev_open, //将 open 字段指向 chrdev_open(...)函数 .read = chrdev_read, //将 read 字段指向 chrdev_read(...)函数 .write = chrdev_write, //将 write 字段指向 chrdev_write(...)函数 .release = chrdev_release, //将 release 字段指向 chrdev_release(...)函数&#125;; //定义 file_operations 结构体类型的变量 cdev_test_ops 操作函数（为应用层操作函数提供接口） 12345678910111213141516171819202122static int chrdev_open(struct inode *inode, struct file *file)&#123; printk(&quot;This is chrdev_open \\n&quot;); return 0;&#125;static ssize_t chrdev_read(struct file *file,char __user *buf, size_t size, loff_t *off)&#123; printk(&quot;This is chrdev_read \\n&quot;); return 0;&#125;static ssize_t chrdev_write(struct file *file,const char __user *buf,size_t size,loff_t *off)&#123; printk(&quot;This is chrdev_write \\n&quot;); return 0;&#125;static int chrdev_release(struct inode *inode, struct file *file)&#123; return 0;&#125; 设备节点 节点创建 手动创建 123# mknod 节点名称 设备类型 主设备号 从设备号# mknod NAME TYPE MAJOR MINORmknod /dev/device_test c 234 0 自动创建 123/* kernel/include/linux/device/class.h *///class_create(节点/结构体/类, 节点名称)#define class_create(owner, name) (&#123;static struct lock_class_key __key; __class_create(owner, name, &amp;__key);&#125;) 节点销毁 销毁 123/* kernel/include/linux/device/class.h *///void class_destroy(节点/结构体/类)void class_destroy(struct class *cls); 设备与节点 设备：字符设备、块设备、网络设备 节点：类 关联 设备创建 123/* kernel/include/linux/device.h *///device_create(节点/结构体/类, 该设备的父设备或NULL, 设备号, 被添加到该设备回调的数据或NULL, 设备节点名称)device_create( (struct class *cls, struct device *parent, dev_t devt,void *drvdata, const char *fmt); 设备销毁 123/* kernel/include/linux/device.h *///device_create(节点/结构体/类, 设备号)void device_destroy(struct class *cls, dev_t devt); 模板记住 字符驱动（记住顺序） 1234567891011121314151617/* 头文件 *//* 1.定义字符设备结构体变量-对象 *//* 2.定义设备号-家庭住址/唯一标识ID *//* 3.定义file_operations结构体类型变量-操作 *//* 1.定义设备节点-类 *//* 4.实现file_operations中的操作函数集-请在3之前声明/放在3之前 *//* 5.模块加载 *//* 5.模块卸载 *//* 参数传入（可选） *//* 符号导出（可选） *//* 开源协议（可选） *//* 作者信息（可选） */ 杂项驱动 固定主设备号10 无需设置设备节点","categories":[],"tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://jianghe-jnhe.github.io/tags/Linux%E9%A9%B1%E5%8A%A8/"}]},{"title":"001-驱动基础","slug":"DriveBasis","date":"2024-09-23T11:30:00.000Z","updated":"2024-09-24T00:24:12.939Z","comments":true,"path":"2024/09/23/DriveBasis/","permalink":"https://jianghe-jnhe.github.io/2024/09/23/DriveBasis/","excerpt":"","text":"基本概念 Linux kernel 由linus等维护Linux的人员开发的内核 https://www.kernel.org/ 例如：linux-5.10.7.tar.gz linux_sdk.tar.gz 由芯片原厂（例如：Rockchip）BSP开发人员基于 Linux kernel 开发，提供给Linux驱动开发人员。 泰山派rk3566的linux sdk: tspi_linux_sdk_repo_20240131.tar.gz 是由立创开发人员写的（类似上面的BSP开发人员） Linux driver Linux驱动开发：在有Linux sdk的基础上进行开发，根据项目需求，决定增、删、改、调哪些外设，为应用开发人员提供驱动接口。 当前学习的内容 准备工作 设备与环境 个人笔记本电脑：Windows 10；gitee；mingw64；北京迅为电子开发板rk3568资料；移动WiFi（192.168.0.3） Ubuntu Linux 20.4：VSCode；make；aarch64-none-linux-gnu；gitee；USB直连移动WiFi（192.168.42.133） Linux开发板：泰山派；gitee；移动WiFi（192.168.0.196） Ubuntu Linux 20.4编译官方提供的linux_sdk.tar.gz（官方指：瑞芯微或嘉立创） 个人存放路径/jnheCode/tspkfb/kernel 交叉编译器环境配置 1sudo vi /etc/profile 123# 末尾添加# export PATH=$PATH:/usr/local/你的交叉编译器/binexport PATH=$PATH:/usr/local/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin 模板记住 驱动模板（全文默写） 12345678/* 头文件 *//* 参数传入（可选） *//* 符号导出（可选） *//* 函数 *//* 模块加载 *//* 模块卸载 *//* 开源协议（可选） *//* 作者信息（可选） */ 123456789101112131415161718192021222324/* 头文件 */#include &lt;linux/init.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;/* 参数传入（可选） *//* 符号导出（可选） *//* 函数 */static int helloworld_init(void)&#123; printk(&quot;helloworld_init\\r\\n&quot;); return 0;&#125;static void helloworld_exit(void)&#123; printk(&quot;helloworld_exit\\r\\n&quot;);&#125;/* 模块加载 */module_init(helloworld_init);/* 模块卸载 */module_exit(helloworld_exit);/* 开源协议（可选） */MODULE_LICENSE(&quot;GPL v2&quot;)/* 作者信息（可选） */MODULE_AUTHOR(&quot;jianghe&quot;) Makefile模板（全文默写） 123# 架构 交叉编译器# 目标 内核路径等# make和make clean 123456789101112# 架构 交叉编译器ARCH = arm64CROSS_COMPILE = aarch64-none-linux-gnu-# 目标 内核路径等obj-m += helloworld.oKDIR := /jnheCode/tspkfb/kernelPWD ?= $(shell pwd)# make和make cleanall: make -C $(KDIR) M=$(PWD) modulesclean: make -C $(KDIR) M=$(PWD) clean 加载与导出 123insmod helloworld.kolsmodrmmod helloworld.ko 参数传入（记住思路） 123/* 定义数据类型 *//* 参数传入函数(重点) *//* 同:驱动模板 */ 布尔型 布尔反值 字符指针 char * 短整型 无符号短整型 整型 无符号整型 长整型 无符号长整型 bool inbool charp short ushort int uint long ulong 12345678910/*- kernel/include/linux/moduleparam.h -*/#include &lt;linux/module.h&gt;/* * name：模块参数的名称 * type：模块参数的数据类型 * perm：模块参数的访问权限 */module_param(name, type, perm) module_param_array(name, type, nump, perm)module_param_string(name, string, len, perm) 12345678910/*- kernel//include/linux/stat.h -*/#define S_IRUSR 00400 /*文件所有者可读*/#define S_IWUSR 00200 /*文件所有者可写*/#define S_IXUSR 00100 /*文件所有者可执行*/#define S_IRGRP 00040 /*与文件所有者同组的用户可读*/#define S_IWGRP 00020 /*与文件所有者同组的用户可写*/#define S_IXGRP 00010 /*与文件所有者同组的用户可执行*/#define S_IROTH 00004 /*与文件所有者不同组的用户可读*/#define S_IWOTH 00002 /*与文件所有者不同组的用户可写*/#define S_IXOTH 00001 /*与文件所有者不同组的用户可可执行*/ 1234# insmod helloworld.ko 参数名=参数值insmod parameter.ko number=100 name=&quot;topeet&quot; para=0,1,2,3,4,5,6,7 str=&quot;itop&quot;lsmodrmmod helloworld.ko 符号导出（记住思路） 123456789//----------------------------/*- kernel/include/linux/export.h -*/#include &lt;linux/module.h&gt;/* 定义数据类型和函数 *//* 导出数据类型和函数 *//* 同:驱动模板 *///----------------------------/* 导入（extern）数据类型和函数 *//* 同:驱动模板 */ 12345678910111213141516//-----------------------/* 定义数据类型和函数 */int num = 10;int add(int a, int b)&#123; return (a+b);&#125;/* 导出数据类型和函数 */EXPORT_SYMBOL(num);EXPORT_SYMBOL(add);/* 同:驱动模板 *///----------------------------/* 导入（extern）数据类型和函数 */extern int num;extern int add(int a, int b);/* 同:驱动模板 */ 12# 加载：先依赖后模块# 卸载：先模块后依赖 ​","categories":[],"tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://jianghe-jnhe.github.io/tags/Linux%E9%A9%B1%E5%8A%A8/"}]},{"title":"单片机串口通用收发功能笔记","slug":"SerialNote","date":"2024-09-04T08:26:56.000Z","updated":"2024-09-04T08:27:03.415Z","comments":true,"path":"2024/09/04/SerialNote/","permalink":"https://jianghe-jnhe.github.io/2024/09/04/SerialNote/","excerpt":"","text":"接收单字节数据前期准备 标准库：用户已经配置好串口的时钟、引脚（MSP层）和UART参数设置，已经配置串口中断； HAL库：使用CubeMX或CubeIDE已经配置好串口的时钟、引脚（MSP层）和UART参数设置，已经配置串口中断； 1234567891011/* 标准库 能够接收1个字节的数据 */uint8_t my_rx_data; //定义串口接收的数据变量void USART1_IRQHandler(void)&#123; if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET) &#123; my_rx_data = USART_ReceiveData(USART1); USART_ClearITPendingBit(USART1, USART_IT_RXNE); &#125;&#125; 12345678910111213141516171819202122/* HAL库 能够接收1个字节的数据 *///main.cuint8_t my_rx_data; //定义串口接收的数据变量int main(void)&#123; HAL_UART_Receive_IT(&amp;huart1,&amp;my_rx_data,1); while(1) &#123; &#125;&#125;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; if(huart == &amp;huart1) &#123; //接收数据 HAL_UART_Receive_IT(&amp;huart1, &amp;my_rx_data, 1); &#125;&#125; 推荐教程 标准库串口收发教程·江协科技 https://www.bilibili.com/video/BV1th411z7sn?p=27 HAL库串口收发教程·keysking https://www.bilibili.com/video/BV1bc411J7Tv/ 接收多个数据 定义一个固定长度的全局数组或字符串； 定义一个用于记录接收数据长度的变量，初试为0，接收累加； 标准库-WIFI为例12345/* .h文件 */#define ESP01S_RX_BUF_MAX_LEN 1024 extern char esp01s_rx_buf[];extern uint16_t esp01s_rx_buf_len;extern uint8_t esp01s_rx_data; 1234567891011121314151617181920/* .c文件 */char esp01s_rx_buf[ ESP01S_RX_BUF_MAX_LEN ];uint16_t esp01s_rx_buf_len = 0;uint8_t esp01s_rx_data;void USART1_IRQHandler(void)&#123; if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET) &#123; esp01s_rx_data = USART_ReceiveData(USART1); if( esp01s_rx_buf_len &lt; (ESP01S_RX_BUF_MAX_LEN-1) ) &#123; esp01s_rx_buf[esp01s_rx_buf_len] = esp01s_rx_data; esp01s_rx_buf_len++; &#125; USART_ClearITPendingBit(USART1, USART_IT_RXNE); &#125;&#125; HAL库-SCPI为例1234#define EL_RX_BUF_MAX_LEN 1024extern char el_rx_buf[];extern uint16_t el_rx_buf_len;extern uint8_t el_rx_data; 1HAL_UART_Receive_IT(&amp;huart1,&amp;el_rx_data,1); 123456789101112131415161718char el_rx_buf[EL_RX_BUF_MAX_LEN];uint16_t el_rx_buf_len = 0;uint8_t el_rx_data = 0;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; if(huart == &amp;huart1) &#123; //接收电子负载的数据 if( el_rx_buf_len &lt; (EL_RX_BUF_MAX_LEN-1) ) &#123; //接收到1个数据，存入 el_rx_buf[el_rx_buf_len] = el_rx_data; el_rx_buf_len++; &#125; HAL_UART_Receive_IT(&amp;huart1, &amp;el_rx_data, 1); &#125;&#125; 以上逻辑同样适用于其他数据接收 接收整个对象 前提：接收的内容格式是制定好的。 按照制定的协议，定义全局结构体，结构体成员为各部分数据； 帧头 模式 长度 数据 CRC 帧尾 0xAA 0x01 | 0x02 0x03 X Y Z 模式+长度+数据 0xFE 123456789101112131415161718#define FRAME_HEAD 0xAA#defien FRAME_TAIL 0xFE// 定义全局结构体typedef struct &#123; uint8_t mode; uint8_t data_len; uint16_t X_axis; uint16_t Y_axis; uint16_t Z_axis; uint8_t CRC_8;&#125; GetData;// 声明全局变量extern GetData g_Get_Data;uint8_t Calculate_CRC8(uint8_t *pData, uint8_t Size);int get_data_from_uart(uint8_t uart_data, uint16_t data_len); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192uint8_t uart1_rx_data; //定义串口接收的数据变量void USART1_IRQHandler(void)&#123; static uint8_t RxState = 0; //定义表示当前状态机状态的静态变量 static int err; if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET) &#123; uart1_rx_data = USART_ReceiveData(USART1); /*当前状态为0，接收数据包包头*/ if (RxState == 0) &#123; if (RxData == FRAME_HEAD) //如果数据确实是包头 &#123; RxState = 1; //置下一个状态 uart1_rx_buf_len = 0; //数据包的位置归零 &#125; &#125; /*当前状态为1，接收数据包数据*/ else if (RxState == 1) &#123; //这里接收全部数据 uart1_rx_buf[uart1_rx_buf_len] = uart1_rx_data; //将数据存入数据包数组的指定位置 uart1_rx_buf_len ++; //数据包的位置自增 if (uart1_rx_buf_len &gt;= 1 + 1 + uart1_rx_buf[1] + 1) &#123; RxState = 2; //置下一个状态 &#125; &#125; /*当前状态为2，接收数据包包尾*/ else if (RxState == 2) &#123; if (uart1_rx_data == FRAME_TAIL) //如果数据确实是包尾部 &#123; //数组中接收完成,放入结构体 err = get_data_from_uart(uart1_rx_buf, uart1_rx_buf_len); if(err) &#123; //CRC错误 &#125; else &#123; RxState = 0; //状态归0 Serial_RxFlag = 1; //接收数据包标志位置1，成功接收一个数据包 &#125; &#125; &#125; USART_ClearITPendingBit(USART1, USART_IT_RXNE); &#125;&#125;int get_data_from_uart(uint8_t uart_data, uint16_t data_len)&#123; g_Get_Data.mode = uart_data[0]; g_Get_Data.data_len = uart_data[1];// g_Get_Data.X_axis = uart_data[2] uart_data[3];// g_Get_Data.Y_axis = uart_data[4] uart_data[5];// g_Get_Data.Z_axis = uart_data[6] uart_data[7]; g_Get_Data.CRC_8 = Calculate_CRC8(uart_data,data_len-1); if( g_Get_Data.CRC_8^uart_data[data_len-1]) &#123; return 1;//err &#125; return 0;&#125;uint8_t Calculate_CRC8(uint8_t *pData, uint8_t Size)&#123; unsigned char i; unsigned char rCRC = 0; unsigned char CRC_8_POLYNOMIAL = 0x29; while(Size--) &#123; rCRC ^= *pData++; for(i=8; i&gt;0; --i) &#123; if(rCRC &amp; 0x80) &#123; rCRC = (rCRC &lt;&lt; 1) ^ CRC_8_POLYNOMIAL; &#125;else &#123; rCRC =(rCRC &lt;&lt; 1); &#125; &#125; &#125; return(rCRC);&#125;","categories":[],"tags":[]},{"title":"新年目标","slug":"myGoal","date":"2023-12-31T16:00:00.000Z","updated":"2024-09-04T08:28:47.329Z","comments":true,"path":"2024/01/01/myGoal/","permalink":"https://jianghe-jnhe.github.io/2024/01/01/myGoal/","excerpt":"","text":"当前阶段 课程 通过所有课程考试，顺利毕业即可 加权平均达到75分，不追求奖学金 技能 单片机学习与实践 ARM学习与实践 OS学习与实践 完成相关工作 做笔记写博客 证书 CET-6 健康 每周五晚跑步","categories":[],"tags":[]},{"title":"主控芯片","slug":"myMCU","date":"2023-12-31T08:45:56.000Z","updated":"2023-12-31T09:13:10.571Z","comments":true,"path":"2023/12/31/myMCU/","permalink":"https://jianghe-jnhe.github.io/2023/12/31/myMCU/","excerpt":"","text":"中心 STM32F103C8T6 72MHz，20k，64k，48pin ARM Cortex-M3 STM32F103C8T6最小系统板 低端 低功耗 STM32F030C8T6 48MHz，8k，64k，48pin ARM Cortex-M0 APM32F030C8T6 48MHz，8k，64k，48pin 极海半导体 实习项目 高端 高主频 STM32F427ZGT6 240MHz，256k，1M，144pin ARM Cortex-M4 GD32F450ZGT6 180Mhz，256k，1M，144pin ARM Cortex-M4 兆易创新 梁山派 HC32F460JEUA 200MHz，192k，512k，48pin ARM Cortex-M4 小华半导体 实验室项目 架构 RISC-V CH32V307VCT6 144MHz，64k，256k，100pin 沁恒微电子 青稞RISC-V通用型开发板 ESP32 WiFi+BlueTooth 智能家居 ESP8266 WiFi 智能家居 IDE Eclipse VSCode Linux makefile（非IDE）","categories":[],"tags":[]},{"title":"资料指南","slug":"Whoami","date":"2023-12-10T02:09:22.000Z","updated":"2024-03-24T06:34:52.125Z","comments":true,"path":"2023/12/10/Whoami/","permalink":"https://jianghe-jnhe.github.io/2023/12/10/Whoami/","excerpt":"","text":"学习经历2019级本科生：通信工程 2021年09月，通过网上找资料和修改引脚完成课程设计：《基于51单片机的倒车雷达系统设计》，制作视频教程与演示视频，上传B站。 2022年02月，在倒车雷达基础上，增加蓝牙遥控小车。制作视频教程、演示视频及资料分享，详见视频简介处，视频已上传B站。 2022年05月，通信工程综合实训，学习《基于ESP8266的物联网智能家居控制》软件开发。 2022年06月，参考网上开源项目，完成《基于ESP8266的太空人时钟小电视》，软硬件及模型已全部免费分享。 2022年11月，基本完成本科毕业设计，《机械臂定点坐标控制系统设计》，参考资料与来源均在B站视频简介处标明。 2023年01月，毕业设计:《机械臂定点坐标控制》全部资料分享出来，资料使用指南视频已上传B站，Gitee开源链接详见视频简介处。 2023年05月，Gitee使用指南。以如何下载倒车雷达资料为例讲解。 2023年05月，机械臂完整教程已上传B站。 2023年07月，考研已结束，实习已结束，大学已毕业，开始商业合作接单。 2023级研究生：仪器科学与技术 2023年09月，第一次尝试与公司商业合作：讲述自己入门单片机的经历，并为其公司推广产品。 2023年10月，开始一边学习一边在实验室打螺丝。 2023年10月，完成接单：《基于STM32的智能衣架控制系统设计》。 2023年11月，完成接单：《基于STM32的智能语音控制系统设计》。 2023年12月，完成接单：《基于STM32的热控制搅拌杯系统设计》。 2024年03月，完成接单：《基于STM32的遥控机械臂控制系统设计》。 20xx年xx月，持续更新ing。 免费资料个人说明本人之前也是小白，什么都不懂，关于51的视频中有一些理解错的地方，请大家主动学习、自主思考，这样才能学到知识；如果不想思考，直接用我的板子就可以了，资料已经很详细并全部分享到Gitee了，没有必要加我要资料；只有需要我帮你做的，可以B站@姜河jnhe私信我，获取联系方式。 关于STM32的机械臂，其实没啥亮点和实际意义，很多算法其实也都有现成的库调用，而我自己写的代码很垃圾，对单片机的理解也不深入，所以大家仅作学习了解；如果仅是需要资料，认真读一下资料获取指南，免费下载用，不用找我要资料。我目前不打算走这个方向，所以不会维护和深入学习。 关于ESP8266的学习资料，我没有分享出来，原因：1.资料过大，且可以在网上找得到；2.开发方式不是Arduion，而是在Windows下使用eclipse，参考ESP8266 SDK开发的，配置很麻烦。我其实不懂，只是跟着技新课堂的视频教程改内容，接入物联网云平台，就算分享给大家，大家也用不了。 其他没有分享出来的，一般是因为那不是我的代码而且我不懂，例如51开发板驱动PCA9685控制机械臂，它来自51黑电子。 资料列表 Gitee下载资料教程 【视频版】https://www.bilibili.com/video/BV1xg4y1j7yb 【文字版】https://www.cnblogs.com/jianghe414/p/17367884.html 《基于51单片机的倒车雷达系统设计》 https://gitee.com/jianghe2022/astern-radar_v2.0 【Gitee下载，全部资料且详细】 https://pan.baidu.com/s/13pzx1tSyKKvMlToUTtk5yQ?pwd=hphu 【网盘下载，未来可能会被清理，下同】 《基于51单片机的蓝牙遥控小车设计》 https://pan.baidu.com/s/1ZiIHiyQp0tu6oA9e6seHmA?pwd=5akx 《基于ESP8266的太空人时钟小电视》 https://pan.baidu.com/s/1qcza0wGSEP7XAkdA8VbwXg?pwd=wcxb 《基于STM32的机械臂定点坐标控制系统设计》 https://gitee.com/jianghe2022/arm-rot_v0.1 商业接单主营业务 单片机毕设、课设软硬件功能实现，论文免费指导； 为公司或企业实现项目功能； 为公司产品做推广视频、科普视频等。 联系方式 B站@姜河jnhe，通过私信方式，加联系方式详谈 https://space.bilibili.com/496375938 随便唠唠RTOS买块成本可接受的开发板，跟着网上的教程学。 LinuxWindows电脑安装虚拟机，虚拟机中安装Linux Ubuntu，Ubuntu中安装QEMU，模拟Linux开发板，不花钱跟着网上的教程学。 免费博客依托Gitee或Github，安装一些前端的工具和HEXO，免费搭建一个属于自己的技术博客，记录和复习自己学的内容，打造自己的名片。","categories":[],"tags":[]},{"title":"初见博客","slug":"hello-world","date":"2023-12-04T05:40:39.955Z","updated":"2023-12-04T06:37:48.971Z","comments":true,"path":"2023/12/04/hello-world/","permalink":"https://jianghe-jnhe.github.io/2023/12/04/hello-world/","excerpt":"","text":"欢迎来到 Hexo！这是你的第一篇文章。查看文档了解更多信息。如果你在使用Hexo时遇到任何问题，你可以在故障排除中找到答案，或者你可以在GitHub上问我。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速入门 Quick Start创建一个新帖 Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing 运行网站服务 Run server1$ hexo server More info: Server 生成静态博客 Generate static files1$ hexo generate More info: Generating 部署到远程站点 Deploy to remote sites1$ hexo deploy More info: Deployment 参考教程文字版·基于Hexo的博客搭建：https://www.cnblogs.com/huanhao/p/hexobase.html视频版·基于Hexo的博客搭建：https://www.bilibili.com/video/BV1cW411A7Jx/","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://jianghe-jnhe.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://jianghe-jnhe.github.io/tags/Linux%E9%A9%B1%E5%8A%A8/"}]}