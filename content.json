{"meta":{"title":"Jnhe","subtitle":"","description":"","author":"Jnhe","url":"https://jianghe-jnhe.github.io","root":"/"},"pages":[],"posts":[{"title":"QT","slug":"QTLayoutandQSS","date":"2024-10-10T14:15:56.000Z","updated":"2024-10-10T14:11:28.391Z","comments":true,"path":"2024/10/10/QTLayoutandQSS/","permalink":"https://jianghe-jnhe.github.io/2024/10/10/QTLayoutandQSS/","excerpt":"","text":"QT界面排版 爱编程的大丙 https://www.bilibili.com/video/BV1Jp4y167R9?p=57 https://www.bilibili.com/video/BV1Jp4y167R9?p=58 布局 水平 垂直 网格：水平+垂直 布局相互嵌套 主界面也要给一个布局 排版方式 Layout（布局） Container（容器）（推荐） 弹簧 可以设置固定值：size Type - Fixed QT QSS https://www.bilibili.com/video/BV1Lu4y1e7er 1234567类&#123; 属性:值&#125;类:子类&#123; 属性:值&#125; UI界面 改变样式表 自己写 把QSS写在一个QString对象中 1QString qss = &quot;QPushButton&#123;color:bule;&#125;&quot;; 然后调用setStyleSheet函数给按钮设置QSS样式 1ui-&gt;pushButton-&gt;setStyleSheet(qss); 导入QSS文件 github获取成套的QSS样式：直接搜QSS（收藏量1.1k及以上的） 创建资源文件 资源文件写入CMakeLists.txt 资源文件中导入QSS文件（以.qss结尾） cpp文件中读取QSS文件 12345QFile file(&quot;:/QSS/Button.qss&quot;);file.open(QFile::ReadOnly);//只读qss = file.readAll();file.close();a.setStyleSheet(qss);","categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://jianghe-jnhe.github.io/tags/QT/"}]},{"title":"enum typedef define","slug":"enum-typedef-define","date":"2024-10-10T05:15:56.000Z","updated":"2024-10-10T07:19:14.730Z","comments":true,"path":"2024/10/10/enum-typedef-define/","permalink":"https://jianghe-jnhe.github.io/2024/10/10/enum-typedef-define/","excerpt":"","text":"enum枚举enum int define 12345enum Color &#123; RED = 1, GREEN, BLUE&#125;; typedef 为现有的数据类型创建一个新的名字。它是一种类型别名声明，使得代码更加清晰和易于维护,提高代码的可读性， 格式 1234567891011121314151617// typedef 存在的数据类型 数据类型新名字;//常见数据类型typedef unsigned char uint8_t; //结构体typedef struct Rectangle&#123; int width; int height;&#125; Rectangle;//函数指针typedef float (*op_t)(int);float calc(int num, op_t op)&#123; return op(num);&#125; #define 内容替换 参数参入 12345678//以下程序的输出结果#define DOUBLE(a) a+aint main()&#123; int n = DOUBLE(5) * 5; printf(&quot;%d\\n&quot;, n)&#125; 12345//正确结果：305+5*5 = 5+25 = 30//错误结果：505+5=1010*5=50","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://jianghe-jnhe.github.io/tags/C/"}]},{"title":"struct union","slug":"struct-union","date":"2024-10-10T04:15:56.000Z","updated":"2024-10-10T07:19:17.031Z","comments":true,"path":"2024/10/10/struct-union/","permalink":"https://jianghe-jnhe.github.io/2024/10/10/struct-union/","excerpt":"","text":"结构体前置typedef 面向对象 指针与数组首地址 结构体作用数据组织-封装 数据抽象、隐藏-接口 数据传递-函数参数 内存分配 代码清晰 面向对象 声明结构体 struct关键字 123456struct Person &#123; char *name; int age;&#125;;//使用struct Person person1; 结构体成员 123person1.nameperson1.ageperson1.height 空结构体：没有成员的结构体（不重要） 匿名结构体：没有名字的结构体（不重要） 1234struct &#123; char *name; int age;&#125;person1,person2; 使用typedef 123456typedef struct Person &#123; char *name; int age;&#125;Person;//使用Person person1; 结构体的嵌套定义：结构体中嵌套结构体 12345678910111213141516typedef struct Birthday &#123; int year;//年份 int month;//月份 int day;//日&#125;Birthday;typedef struct Person &#123; char *name; int age; Birthday birthday; //....&#125;Person;//使用，两层访问Person person1;int my_year = person1.birthday.year; 结构体变量12345678910111213//蓝图：不占内存typedef struct Birthday &#123; int year;//年份 int month;//月份 int day;//日&#125;Birthday;//蓝图：不占内存typedef struct Person &#123; char *name; int age; Birthday birthday;&#125;Person; 声明结构体变量 12//数据类型 变量1, 变量2;Person person1, person2; 结构体变量赋值 12345678910111213//按照声明的顺序赋值Person person1 = &#123; &quot;jianghe&quot;, 23, &#123;2002, 4, 14&#125; &#125;;//不按照顺序Person person1 = &#123; .birthday = &#123; .year = 2002, .month = 4, .day = 14, &#125;, .age = 23, .name = &quot;jianghe&quot;, &#125;; 访问成员结构体成员 1234//使用&#x27;.&#x27;printf(&quot;姓名：%s\\t年龄：%d\\t生日：%d-%d-%d\\r\\n&quot;, person1.name, person1.age, person1.birthday.year, person1.birthday.month, person1.birthday.day); 结构体作为函数参数 123456void printPersonInfo(Person person)&#123; printf(&quot;姓名：%s\\t年龄：%d\\t生日：%d-%d-%d\\r\\n&quot;, person.name, person.age, person.birthday.year, person.birthday.month, person.birthday.day); &#125; 上述函数参数传递的是值，所有值赋值了一遍，为了更快捷传递，可以使用结构体指针传递，如下 结构体指针 声明结构体指针 123456Person person1 = &#123; &quot;jianghe&quot;, 23, &#123;2002, 4, 14&#125; &#125;;//声明结构体指针Person *pperson1 = &amp;person1;printPersonInfo(pperson1);//指针的必须用箭头&#x27;-&gt;&#x27;，不用用&#x27;.&#x27; 结构体指针访问结构体成员 1234567void printPersonInfo(Person *pperson)&#123; printf(&quot;姓名：%s\\t年龄：%d\\t生日：%d-%d-%d\\r\\n&quot;, pperson-&gt;name, pperson-&gt;age, pperson-&gt;birthday.year, pperson-&gt;birthday.month, pperson-&gt;birthday.day); //指针的必须用箭头&#x27;-&gt;&#x27;，不用用&#x27;.&#x27;&#125; 结构体指针作为函数参数（如上所示） 结构体返回 面向对象思想：所有内容封装在一起，形成一个包（类似于数组，但是数据类型多样）返回 如果要返回多个结构体，可以用指针，见下面的结构体数组 123456789101112131415161718192021222324//蓝图：不占内存typedef struct Birthday &#123; int year;//年份 int month;//月份 int day;//日&#125;Birthday;//蓝图：不占内存typedef struct Person &#123; char *name; int age; Birthday birthday;&#125;Person;Person getPersonInfo(void)&#123; //获取 Person person = &#123; &quot;jianghe&quot;, 23, &#123;2002, 4, 14&#125; &#125;; return person;//返回&#125;//使用Person myPerson = getPerson(); 结构体数组1Person person[3];//定义三个结构体 当你用数组表示其中一个结构体的时候，其实就把它当成一个结构体就可以了。同上。 结构体内存 内存对齐 结构体的总大小必须为：结构体最宽基本类型成员大小的整数倍 节约空间 调整成员，有时候可以减少缝隙，节约空间 联合体内存union 共用体 节约内存空间 联合体成员：共享同一个内存位置； 联合体大小：最宽成员长度 同一时刻只能有1个成员允许有1个值。 联合体使得程序员可以通过不同方式使用同一个内存位置。 结构体位域 程序员在结构体中指定成员变量所占用的位数。这在需要精确控制数据存储大小和对齐方式时非常有用，尤其是在嵌入式编程或者网络协议设计中。 位域的使用可以减少内存的使用，因为它允许你将多个布尔值或小的整数值紧凑地存储在单个字节或几个字节中。 位域的使用（不学了）","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://jianghe-jnhe.github.io/tags/C/"}]},{"title":"make cmake","slug":"make-cmake","date":"2024-10-10T01:15:56.000Z","updated":"2024-10-10T07:19:19.593Z","comments":true,"path":"2024/10/10/make-cmake/","permalink":"https://jianghe-jnhe.github.io/2024/10/10/make-cmake/","excerpt":"","text":"安装与配置 安装（略） 环境配置（略） make与Makefile 于仕琪：https://www.bilibili.com/video/BV188411L7d2/ 格式 1234567&lt;target&gt; : &lt;prerequisites&gt;[tab] &lt;commands&gt;目标(必选) : 前置条件/依赖(可选) shell命令(可选) # 依赖与命令至少有一个 其他 模式匹配 赋值操作 伪目标 警告打印 Makefile 123## VERSION 1main: main.c gcc -o main main.c 123456789101112## VERSION 2CXX = gccTARGET = mainOBJ = main.o $(TARGET): $(OBJ) $(CXX) -o $(TARGET) $(OBJ)main.o: main.c $(CXX) -c main.c# other files 1234567891011121314151617181920## VERSION 3CXX = gccTARGET = mainOBJ = main.oCXXFLAGS = -c -Wall#源文件路径SUBDIR := $(shell pwd)#生成目标文件$(TARGET): $(OBJ) $(CXX) -o $@ $^%.o: %.c $(CXX) $(CXXFLAGS) $&lt; -o $@.PHONY: cleanclean: rm -f *.o $(TARGET) 1234567891011121314151617## VERSION 4CXX = gccTARGET = mainSRC = $(wildcard *.c)OBJ = $(patsubst %.o, $(SRC))CXXFLAGS = -c -Wall$(TARGET): $(OBJ) $(CXX) -o $@ $^%.o: %.c $(CXX) $(CXXFLAGS) $&lt; -o $@.PHONY: cleanclean: rm -f *.o $(TARGET) make与Linux Kernel1234567891011121314# 架构 交叉编译器ARCH = arm64CROSS_COMPILE = aarch64-none-linux-gnu-# 目标 内核路径等obj-m += helloworld.oKDIR := /jnheCode/tspkfb/kernelPWD ?= $(shell pwd)# make和make cleanall: make -C $(KDIR) M=$(PWD) modulesclean: make -C $(KDIR) M=$(PWD) clean cmake与CMakeLists.txt 于仕琪：https://www.bilibili.com/video/BV1bg411p7oS/ 格式 12345cmake_minimum_required(VERSION 3.10)project(hello)add_executable(hello main.c otherfile.c) build文件 1234567891011mkdir buildcd buildcmake .../hellocd ..rm -rf build","categories":[],"tags":[{"name":"C","slug":"C","permalink":"https://jianghe-jnhe.github.io/tags/C/"}]},{"title":"MLX90640中文API","slug":"MLX90640","date":"2024-10-04T08:26:56.000Z","updated":"2024-10-04T13:04:24.972Z","comments":true,"path":"2024/10/04/MLX90640/","permalink":"https://jianghe-jnhe.github.io/2024/10/04/MLX90640/","excerpt":"","text":"1. 概述为了使用MLX90640驱动程序，C项目中应该包含4个文件: MLX90640_I2C_Driver.h — 包含I2C相关函数定义的头文件 MLX90640_API.h — 包含MLX90640特定函数定义的头文件 MLX90640_API.c —包含MLX90640特定功能的文件（原文是MLX90640_API.cpp） （原文中只有3个文件，这里说4个文件，应该是指需要一个MCU硬件I2C或者软件模拟I2C的C驱动程序，详见第2章） 2. I2C驱动这是I2C通信的驱动程序。用户应该相应地实现这个驱动程序，以便与MLX90640实现适当的I2C。由于这些函数是由MLX90640 API使用的，因此不应该更改函数定义，函数实现应该使用适当的输入和输出。I2C标准首先读取低字节（LSByte），反转数据的端序。注意，驱动程序还负责重建正确的端序。如果更改了这部分代码，则应注意正确地恢复数据。 2.1. I2C驱动函数I2C驱动有五个主要功能，确保用户MCU和MLX90640之间的正常通信。这些功能的实现需要由用户来完成。但是，保持相同的函数定义非常重要。 2.1.1. void MLX90640_I2CInit(void)如果需要，这个函数应该用于初始化I2C线路(sda和scl)和I2C硬件模块。I2C线路的初始状态应该是高的。在此函数中生成停止条件还允许重置所有可能正在进行的通信。这可以帮助避免由于初始化过程中错误启动I2C序列而导致的通信失败。 例如： I2C的初始化应该在程序开始时完成，以确保正确的通信 main.c ​ …定义的内容… ​ …MCU 初始化 ​ MLX90640_I2CInit(); ​ … ​ …MLX90640 通信 ​ …用户代码 2.1.2. void MLX90640_I2CFreqSet(int freq) 此功能应用于动态更改I2C频率和&#x2F;或粗设置。它有一个int类型的形参。该参数用于设置硬件I2C模块的工作频率，对于软件I2C驱动，用于设置Wait函数的周期数。当使用I2C硬件模块时，MCU供应商提供的库具有集成的频率更改功能。在这种情况下，应该更改MLX90640 I2C驱动程序，以便它使用库函数来设置频率。在软件I2C驱动程序的情况下(当使用两个通用IOs时)，I2CFreqSet函数可以设置一个全局变量，该变量被Wait函数用来设置循环的数量。为了适当地设置频率，用户应该修剪Wait功能，以便在MLX90640设备传输数据时生成的I2C时钟具有所需的频率。 例如： 使用硬件I2C模块时，将I2C频率设置为1MHz，读取帧数据: MLX90640_I2CFreqSet(1000); &#x2F;&#x2F;在这种情况下，MCU供应商提供的库函数要求int值在KHz -&gt; 1000KHz &#x3D; 1MHz 使用软件I2C实现时，将I2C频率设置为400KHz以读取帧数据: MLX90640_I2CFreqSet(20); &#x2F;&#x2F;根据指令周期和单片机时钟的不同， ​ &#x2F;&#x2F;等待函数中的20个周期导致MLX90640在传输数据时生成的scl频率为400KHz 2.1.3. int MLX90640_I2CRead(uint8_t slaveAddr,uint16_t startAddress, uint16_t nMemAddressRead, uint16_t *data)该函数从给定地址开始从选定的MLX90640设备存储器中读取所需数量的字，并将数据存储在用户定义的MCU存储器位置中。请注意，当I2C读通信正在进行时，地址位置正在自动增加，但是如果发起了新的读通信，地址将被重置。因此，如果应该在多个I2C读命令中转储大内存，则应该特别注意使用适当的起始地址。如果返回值为0，表示通信成功;如果返回值为-1，表示通信过程中发生NACK。该函数需要以下参数: uint8_t slaveAddr — MLX90640设备从地址(默认从地址为0x33) uint16_t startAddress — 要从MLX90640存储器中读取的第一个地址。MLX90640 EEPROM位于地址范围0x2400至0x273F, MLX90640 RAM位于地址范围0x0400至0x073F。 uint16_t nMemAddressRead — 要从MLX90640存储器中读取的16位字的数目 uint16_t *data — 指向用户想要存储数据的MCU存储器位置的指针 例如： 读取单个EEPROM值- MLX90640设置的MLX90640设备与从地址0x33: 12uint16_t eeValue;MLX90640_I2CRead (0x33, 0x240C, 1, &amp;eeValue); // EEPROM 0x240C cell值存储在eeValue中 读取从地址为0x33的MLX90640设备的整帧数据: 12static uint16_t frameData[832];MLX90640_I2CRead(0x33, 0x0400, 832, frameData);//帧数据存储在frameData数组中 2.1.4. int MLX90640_I2CWrite(uint8_t slaveAddr,uint16_t writeAddress, uint16_t data)该函数将16位值写入所选MLX90640设备的所需内存地址。该函数在写操作完成后回读数据，如果写成功返回0，如果在通信过程中发生NACK返回-1，如果内存中的数据与预期的数据不相同返回-2。需要设置的参数如下: uint8_t slaveAddr — MLX90640设备从地址(默认从地址为0x33) uint16_t writeAddress — 要写入数据的MLX90640内存地址 uint16_t data — 要写入MLX90640内存地址的数据 例如： 写入设置- MLX90640设置的MLX90640设备与从地址0x33: 123int status;status = MLX90640_I2CWrite(0x33, 0x800D, 0x0901); //所需的设置被写入地址0x800D//如果写入成功，变量状态为0。 2.1.5. int MLX90640_I2CGeneralReset(void)这个函数应该实现I2C的标准复位条件。根据I2C规范，复位条件是发送0x06到地址0x00。如果通信成功，该函数返回0;如果在通信过程中发生了NAK，则返回-1。注意，这个函数将重置总线上支持它的所有设备。 例如： 复位总线上的所有设备: 123int status;status = MLX90640_I2CGeneralReset(); //复位MLX90640设备//如果通信成功，变量状态为0。 3. MLX90640 API这是MLX90640设备的驱动程序。用户不应该更改这个驱动程序。 3.1. MLX90640 配置函数3.1.1. int MLX90640_SetResolution(uint8_t slaveAddr, uint8_t resolution);该函数在适当的寄存器中写入所需的分辨率值(0x00到0x03)，以便更改具有给定从地址的MLX90640设备的当前分辨率。注意，上电复位后，分辨率将恢复到存储在EEPROM中的分辨率。如果写入成功，返回值为0，如果通信过程中发生NACK，返回值为-1，如果写入值与预期值不相同，返回值为-2。 uint8_t resolution — MLX90640的当前分辨率 0x00 - 16位分辨率 0x01 - 17位分辨率 0x02 - 18位分辨率 0x03 - 19位分辨率 例如： 设置从地址0x33的MLX90640设备以19位分辨率工作: 12Int status;status = MLX90640_SetResolution (0x33,0x03); 3.1.2. int MLX90640_GetCurResolution(uint8_t slaveAddr);该函数返回具有给定从属地址的MLX90640设备的当前分辨率。请注意，当前分辨率可能与该设备的EEPROM中设置的分辨率不同。如果结果为-1，说明在通信过程中发生了NACK，这不是一个有效的解析数据。 uint8_t slaveAddr — MLX90640设备从地址(默认从地址为0x33) 例如： 从从地址0x33的MLX90640设备获取当前分辨率，该设备使用19位分辨率，但在EEPROM中编程为16位分辨率: 123int curResolution;curResolution = MLX90640_GetCurResolution (0x33); //curResolution = 0x03(19位)，因为这是设备正在使用的实际分辨率 3.1.3. int MLX90640_SetRefreshRate(uint8_t slaveAddr, uint8_t refreshRate);该函数在适当的寄存器中写入所需的刷新率值(0x00到0x07)，以便更改具有给定从地址的MLX90640设备的当前刷新率。注意，上电复位后，刷新率将恢复到存储在EEPROM中的刷新率。如果写入成功，返回值为0，如果通信过程中发生NACK，返回值为-1，如果写入值与预期值不相同，返回值为-2。 uint8_t slaveAddr — MLX90640设备从地址(默认从地址为0x33) uint8_t refreshRate — MLX90640设备当前的刷新率 0x00 – 0.5Hz 0x01 – 1Hz 0x02 – 2Hz 0x03 – 4Hz 0x04 – 8Hz 0x05 – 16Hz 0x06 – 32Hz 0x07 – 64Hz 例如： 设置从地址0x33的MLX90640设备以16Hz刷新率工作: 12int status;status = MLX90640_SetRefreshRate (0x33,0x05); 3.1.4. int MLX90640_GetRefreshRate(uint8_t slaveAddr);该函数返回具有给定从属地址的MLX90640设备的当前刷新率。请注意，当前的刷新率可能与该设备的EEPROM中设置的刷新率不同。如果结果为-1，则在通信期间发生了NACK，这不是有效的刷新率数据。 3.1.5. int MLX90640_GetSubPageNumber(uint16_t *frameData);这个函数返回MLX90640设备选定帧数据的子页面。 uint16_t *frameData — 指向已经获取的MLX90640帧数据的指针 例如： 获取MLX90640设备选定帧数据的子页面: 123static int mlx90640Frame[834];int Subpage;Subpage = MLX90640_GetSubPageNumber(mlx90640Frame); // Subpage = 1，因为这是该帧的实际子页面编号 3.1.6. int MLX90640_SetInterleavedMode(uint8_t slaveAddr);该函数将具有给定从地址的MLX90640设备设置为交错模式。注意，上电复位后，模式将恢复到存储在EEPROM中的模式。如果写入成功，返回值为0，如果通信过程中发生NACK，返回值为-1，如果写入值与预期值不相同，返回值为-2。 3.1.7. int MLX90640_SetChessMode(uint8_t slaveAddr);该函数将具有给定从属地址的MLX90640设备设置为象棋模式。注意，上电复位后，模式将恢复到存储在EEPROM中的模式。如果写入成功，返回值为0，如果通信过程中发生NACK，返回值为-1，如果写入值与预期值不相同，返回值为-2。 3.1.8. int MLX90640_GetCurMode(uint8_t slaveAddr);该函数返回MLX90640设备的工作模式。 uint8_t slaveAddr — MLX90640设备从地址(默认从地址为0x33) 例如： 获取从地址为0x33的MLX90640设备的工作模式: 123int mode;mode = MLX90640_GetCurMode (0x33); //如果设置了交错模式，Mode = 0；如果设置了象棋模式Mode = 1。 3.2. MLX90640的预处理函数这些API函数通常只在上电复位后调用一次，以提取正确计算温度所需的所有参数 3.2.1. int MLX90640_DumpEE(uint8_t slaveAddr, uint16_t *eeData);该函数从具有给定从地址的MLX90640设备读取所有必要的EEPROM数据到用户定义的MCU存储器位置（Dump 转储）。为保证正常运行，分配的内存至少应为832个字。如果结果是-1，在通信期间发生了NACK，这不是一个有效的EEPROM数据。 3.2.2. int MLX90640_ExtractParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);该函数从给定的EEPROM数据数组中提取参数，并将值存储为MLX90640_API.h中定义的类型。提取（Extract）参数（Parameters）后，不再需要EEPROM数据，其存储的内存可以重复使用。如果返回值为-7，则指定位置的EEPROM数据不是有效的MLX90640 EEPROM，并且参数提取被中止。 uint16_t *eeData — 指向数组的指针，该数组包含要从中提取参数的EEPROM *paramsMLX90640 *mlx90640 *— 指向类型为paramsMLX90640的变量的指针，在该变量中存储提取的参数。注意，如果在线上有多个MLX90640设备，则可以使用paramsMLX90640类型的数组 例如： 从MLX90640设备的EEPROM中提取参数: 12345678910111213141516171819202122232425262728293031323334353637383940unsigned char slaveAddress;static uint16_t eeMLX90640[832];paramsMLX90640 mlx90640;int status;status = MLX90640_DumpEE (slaveAddress, eeMLX90640); //参数从存储在eeMLX90640数组中的EEPROM数据中提取，并存储在类型为paramsMLX90640的mlx90640变量中status = MLX90640_ExtractParameters(eeMLX90640, &amp;mlx90640); /* typedef struct &#123; int16_t kVdd; int16_t vdd25; float KvPTAT; float KtPTAT; uint16_t vPTAT25; float alphaPTAT; int16_t gainEE; float tgc; float cpKv; float cpKta; uint8_t resolutionEE; uint8_t calibrationModeEE; float KsTa; float ksTo[5]; int16_t ct[5]; uint16_t alpha[768]; uint8_t alphaScale; int16_t offset[768]; int8_t kta[768]; uint8_t ktaScale; int8_t kv[768]; uint8_t kvScale; float cpAlpha[2]; int16_t cpOffset[2]; float ilChessC[3]; uint16_t brokenPixels[5]; uint16_t outlierPixels[5]; &#125; paramsMLX90640;*/ 3.3. MLX90640的数据采集函数确保正确数据采集的API函数。 3.3.1 int MLX90640_SynchFrame(uint8_t slaveAddr);该函数等待具有给定从属地址的MLX90640设备可用的新数据。该函数的目的是与MLX90640设备同步，以便在数据可用后立即启动数据采集。这将增加在获得新数据之前的可用读取时间。当数据采集和信号处理所需的时间与传感器的刷新时间相当时，该功能特别有用。建议在读取第一帧之前使用帧同步。对于某些系统来说，每隔一段时间重新同步一次可能会有所帮助。这些同步的速率取决于数据处理时间和传感器刷新时间之间的关系。数据处理时间越快，同步速率越慢。如果结果为-1，说明通信过程中发生了NACK，很可能同步失败。请注意，如果在调用函数时已经有新的可用数据，它将被忽略。 3.3.2. int MLX90640_TriggerMeasurement(uint8_t slaveAddr);该功能使用I2C标准中描述的global reset命令。如果结果是-2，通信过程中发生了NAK，如果结果是-2，内存写入失败，如果结果是-9，触发不成功，如果结果是0 -触发了测量。触发后，设备总是先测量子页面0，然后再测量子页面1。请注意，此函数将重置支持该命令的同一I2C总线上的所有设备。 3.3.3 int MLX90640_GetFrameData(uint8_t slaveAddr, uint16_t *frameData);该函数从具有给定从地址的MLX90640设备读取所有必要的帧数据到用户定义的MCU存储器位置。为保证正常运行，分配的内存至少应为834个字。如果结果为-1，说明在通信过程中发生了NACK，这不是一个有效的帧数据，否则如果结果为-8，说明数据在一定时间内无法获取，帧数据损坏-最有可能的原因是I2C频率太低，否则结果是获取数据的子页面。 3.4. MLX90640的计算相关函数为了得到正确计算的温度，应该按一定顺序调用的API函数。 3.4.1 float MLX90640_GetVdd(uint16_t *frameData, const paramsMLX90640 *params);该函数从给定的MLX90640帧数据和提取的参数返回当前Vdd（电压，eg: 3.3V）。结果是一个浮点数。 3.4.2 float MLX90640_GetTa(uint16_t *frameData, const paramsMLX90640 *params);该函数返回在给定MLX90640帧数据和提取的参数中测量的当前Ta（温度，eg：27.18℃）。结果是一个浮点数。 3.4.3 void MLX90640_CalculateTo(uint16_t *frameData, const paramsMLX90640 *params, float emissivity, float tr, float *result);该函数根据从MLX90640设备读取的帧数据-frame data、为该特定设备提取的参数-parameters和用户定义的发射率-emissivity 和反射温度-reflected Temperature，计算帧中所有768个像素的对象温度。为保证正常运行，分配的内存至少应为768个字。 注意:如果不需要绝对温度值，可以使用MLX90640_GetImage()函数代替。在这种情况下，不应该调用MLX90640_ CalculateTo()函数。 uint16_t *frameData — 指向用户想要存储帧数据的MCU内存位置的指针 paramsMLX90640 *params— 指向MCU内存位置的指针，其中存储了MLX90640设备已提取的参数 float emissivity— 发射率由用户定义。发射率是被测物体的一种特性 float tr— 反射温度由用户定义。如果物体的发射率小于1，则可能有一些温度从物体反射。为了补偿这一点，用户应该输入这个反射温度。可以使用传感器环境温度，但可能需要根据外壳进行一些转换。对于露天的MLX90640，温度变化为-8°C。 float *result— 指向用户希望存储对象温度数据的MCU内存位置的指针 例如： 计算一帧内所有像素点的物体温度，物体发射率为0.95，反射温度为23.15℃(由用户测量): 1234567891011121314float emissivity = 0.95;float tr;unsigned char slaveAddress;static uint16_t eeMLX90640[832];static uint16_t mlx90640Frame[834];paramsMLX90640 mlx90640;static float mlx90640To[768];int status;status = MLX90640_DumpEE (slaveAddress, eeMLX90640); status = MLX90640_ExtractParameters(eeMLX90640, &amp;mlx90640);status = MLX90640_GetFrameData (0x33, mlx90640Frame );tr = 23.15;//一个帧中所有768个像素的对象温度存储在mlx90640To数组中MLX90640_CalculateTo(mlx90640Frame, &amp;mlx90640, emissivity, tr, mlx90640To); 计算一帧内所有像素点的物体温度，物体发射率为0.95，反射温度为传感器环境温度: 123456789101112131415#define TA_SHIFT 8 // MLX90640设备在露天的默认位移float emissivity = 0.95;float tr;unsigned char slaveAddress;static uint16_t eeMLX90640[832];static uint16_t mlx90640Frame[834];paramsMLX90640 mlx90640;static float mlx90640To[768];int status;status = MLX90640_DumpEE (slaveAddress, eeMLX90640); status = MLX90640_ExtractParameters(eeMLX90640, &amp;mlx90640);status = MLX90640_GetFrameData (0x33, mlx90640Frame );tr = MLX90640_GetTa(mlx90640Frame, &amp;mlx90640) – TA_SHIFT;//基于传感器环境温度的反射温度//一个帧中所有768个像素的对象温度存储在mlx90640To数组中MLX90640_CalculateTo(mlx90640Frame, &amp;mlx90640, emissivity, tr, mlx90640To); 3.4.4 void MLX90640_GetImage(uint16_t *frameData, const paramsMLX90640 *params, float *result);该函数根据从MLX90640设备读取的帧数据和为该特定设备提取的参数计算帧中所有768个像素的值。为保证正常运行，分配的内存至少应为768个字。该值越小，像素视场中的温度越低。注意，这些都是带符号的值。 注意:如果需要绝对温度值，则应该使用MLX90640_CalculateTo()。在这种情况下，不应该调用函数MLX90640_GetImage()。 uint16_t *frameData — 指向用户希望存储帧数据的MCU内存位置的指针 *paramsMLX90640 *params *— 指向MCU内存位置的指针，其中存储了MLX90640设备已提取的参数 *float *result *— 指向用户希望存储对象温度数据的MCU内存位置的指针 例如： 获取一个帧的图像: 1234567891011unsigned char slaveAddress;static uint16_t eeMLX90640[832];static uint16_t mlx90640Frame[834];paramsMLX90640 mlx90640;static float mlx90640Image[768];int status;status = MLX90640_DumpEE (slaveAddress, eeMLX90640); status = MLX90640_ExtractParameters(eeMLX90640, &amp;mlx90640);status = MLX90640_GetFrameData (0x33, mlx90640Frame );MLX90640_GetImage(mlx90640Frame, &amp;mlx90640, mlx90640Image);//从帧数据中提取图像并存储在mlx90640Image数组中 3.5. MLX90640支持图像处理的函数可用于图像处理的API函数。 3.5.1 void MLX90640_BadPixelsCorrection(uint16_t *pixels, float *to, int mode, paramsMLX90640 *params);这个函数修正了坏像素和&#x2F;或异常像素的值。像素数组中所有像素索引的值（直到读取到值0xFFFF）将使用不同的过滤方法进行修正。在paramsMLX90640数组brokenPixels和outlierPixels中已经报告了标记为坏像素或异常像素的像素。请注意，可以通过创建一个包含那些像素索引的自定义列表来选择要修正的像素。列表应该以0xFFFF结尾。 uint16_t *pixels — 指向包含待校正像素的数组的指针。 注意：数组应该包含像素的索引(0到767)，0xFFFF应该用作终止值 float *to — 指向对象温度值数组的指针。通过覆盖对应像素指数的当前温度值来校正像素值 int mode — MLX90640设备当前的工作模式 0 — 交错模式 1 — 棋盘模式 paramsMLX90640 *params — 指向MCU内存位置的指针，其中存储了MLX90640设备已提取的参数 例如： 在一帧中修正对象温度为所有像素被标记为坏的或异常的: 1234567891011121314151617float emissivity = 0.95;float tr;unsigned char slaveAddress;static uint16_t eeMLX90640[832];static uint16_t mlx90640Frame[834];paramsMLX90640 mlx90640;static float mlx90640To[768];int status;status = MLX90640_DumpEE (slaveAddress, eeMLX90640); status = MLX90640_ExtractParameters(eeMLX90640, &amp;mlx90640);mode = MLX90640_GetCurMode(slaveAddress);status = MLX90640_GetFrameData (0x33, mlx90640Frame );tr = 23.15;MLX90640_CalculateTo(mlx90640Frame, &amp;mlx90640, emissivity, tr, mlx90640To);MLX90640_BadPixelsCorrection((&amp;mlx90640)-&gt;brokenPixels, mlx90640To, mode, &amp;mlx90640);MLX90640_BadPixelsCorrection((&amp;mlx90640)-&gt;outlierPixels, mlx90640To, mode, &amp;mlx90640);//修正值在mlx90640To数组中 使用自定义列表修正所有所需像素的对象温度: 1234567891011121314151617float emissivity = 0.95;float tr;unsigned char slaveAddress;static uint16_t eeMLX90640[832];static uint16_t mlx90640Frame[834];paramsMLX90640 mlx90640;static float mlx90640To[768];static uint16_t badPixels[5] = &#123;0, 35, 150, 500, 0xFFFF&#125;; //create a custom list of pixels to correctint status;status = MLX90640_DumpEE (slaveAddress, eeMLX90640); status = MLX90640_ExtractParameters(eeMLX90640, &amp;mlx90640);mode = MLX90640_GetCurMode(slaveAddress);status = MLX90640_GetFrameData (0x33, mlx90640Frame );tr = 23.15;MLX90640_CalculateTo(mlx90640Frame, &amp;mlx90640, emissivity, tr, mlx90640To);MLX90640_BadPixelsCorrection(badPixels, mlx90640To, mode, &amp;mlx90640);//修正值在mlx90640To数组中 4. 历史版本表 我不写了 5. 程序源码 原文中没有本章节 MLX90640_I2C_Driver.h12345678910111213141516171819202122232425262728/** * @copyright (C) 2017 Melexis N.V. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */#ifndef _MLX90640_I2C_Driver_H_#define _MLX90640_I2C_Driver_H_#include &lt;stdint.h&gt;#include &quot;MLX90640_API.h&quot; extern void MLX90640_I2CInit(void); extern int MLX90640_I2CGeneralReset(void); extern int MLX90640_I2CRead(uint8_t slaveAddr,uint16_t startAddress, uint16_t nMemAddressRead, uint16_t *data); extern int MLX90640_I2CWrite(uint8_t slaveAddr,uint16_t writeAddress, uint16_t data); extern void MLX90640_I2CFreqSet(int freq);#endif MLX90640_API.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/** * @copyright (C) 2017 Melexis N.V. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */#ifndef _MLX90640_API_H_#define _MLX90640_API_H_#define MLX90640_NO_ERROR 0#define MLX90640_I2C_NACK_ERROR 1#define MLX90640_I2C_WRITE_ERROR 2#define MLX90640_BROKEN_PIXELS_NUM_ERROR 3#define MLX90640_OUTLIER_PIXELS_NUM_ERROR 4#define MLX90640_BAD_PIXELS_NUM_ERROR 5#define MLX90640_ADJACENT_BAD_PIXELS_ERROR 6#define MLX90640_EEPROM_DATA_ERROR 7#define MLX90640_FRAME_DATA_ERROR 8#define MLX90640_MEAS_TRIGGER_ERROR 9#define BIT_MASK(x) (1UL &lt;&lt; (x))#define REG_MASK(sbit,nbits) ~((~(~0UL &lt;&lt; (nbits))) &lt;&lt; (sbit))#define MLX90640_EEPROM_START_ADDRESS 0x2400#define MLX90640_EEPROM_DUMP_NUM 832#define MLX90640_PIXEL_DATA_START_ADDRESS 0x0400#define MLX90640_PIXEL_NUM 768#define MLX90640_LINE_NUM 24#define MLX90640_COLUMN_NUM 32#define MLX90640_LINE_SIZE 32#define MLX90640_COLUMN_SIZE 24#define MLX90640_AUX_DATA_START_ADDRESS 0x0700#define MLX90640_AUX_NUM 64#define MLX90640_STATUS_REG 0x8000#define MLX90640_INIT_STATUS_VALUE 0x0030#define MLX90640_STAT_FRAME_MASK BIT_MASK(0) #define MLX90640_GET_FRAME(reg_value) (reg_value &amp; MLX90640_STAT_FRAME_MASK)#define MLX90640_STAT_DATA_READY_MASK BIT_MASK(3) #define MLX90640_GET_DATA_READY(reg_value) (reg_value &amp; MLX90640_STAT_DATA_READY_MASK)#define MLX90640_CTRL_REG 0x800D#define MLX90640_CTRL_TRIG_READY_MASK BIT_MASK(15) #define MLX90640_CTRL_REFRESH_SHIFT 7#define MLX90640_CTRL_REFRESH_MASK REG_MASK(MLX90640_CTRL_REFRESH_SHIFT,3)#define MLX90640_CTRL_RESOLUTION_SHIFT 10#define MLX90640_CTRL_RESOLUTION_MASK REG_MASK(MLX90640_CTRL_RESOLUTION_SHIFT,2)#define MLX90640_CTRL_MEAS_MODE_SHIFT 12#define MLX90640_CTRL_MEAS_MODE_MASK BIT_MASK(12)#define MLX90640_MS_BYTE_SHIFT 8#define MLX90640_MS_BYTE_MASK 0xFF00#define MLX90640_LS_BYTE_MASK 0x00FF#define MLX90640_MS_BYTE(reg16) ((reg16 &amp; MLX90640_MS_BYTE_MASK) &gt;&gt; MLX90640_MS_BYTE_SHIFT)#define MLX90640_LS_BYTE(reg16) (reg16 &amp; MLX90640_LS_BYTE_MASK)#define MLX90640_MSBITS_6_MASK 0xFC00#define MLX90640_LSBITS_10_MASK 0x03FF#define MLX90640_NIBBLE1_MASK 0x000F#define MLX90640_NIBBLE2_MASK 0x00F0#define MLX90640_NIBBLE3_MASK 0x0F00#define MLX90640_NIBBLE4_MASK 0xF000#define MLX90640_NIBBLE1(reg16) ((reg16 &amp; MLX90640_NIBBLE1_MASK))#define MLX90640_NIBBLE2(reg16) ((reg16 &amp; MLX90640_NIBBLE2_MASK) &gt;&gt; 4)#define MLX90640_NIBBLE3(reg16) ((reg16 &amp; MLX90640_NIBBLE3_MASK) &gt;&gt; 8)#define MLX90640_NIBBLE4(reg16) ((reg16 &amp; MLX90640_NIBBLE4_MASK) &gt;&gt; 12)#define POW2(x) pow(2, (double)x) #define SCALEALPHA 0.000001 typedef struct &#123; int16_t kVdd; int16_t vdd25; float KvPTAT; float KtPTAT; uint16_t vPTAT25; float alphaPTAT; int16_t gainEE; float tgc; float cpKv; float cpKta; uint8_t resolutionEE; uint8_t calibrationModeEE; float KsTa; float ksTo[5]; int16_t ct[5]; uint16_t alpha[768]; uint8_t alphaScale; int16_t offset[768]; int8_t kta[768]; uint8_t ktaScale; int8_t kv[768]; uint8_t kvScale; float cpAlpha[2]; int16_t cpOffset[2]; float ilChessC[3]; uint16_t brokenPixels[5]; uint16_t outlierPixels[5]; &#125; paramsMLX90640; int MLX90640_DumpEE(uint8_t slaveAddr, uint16_t *eeData); int MLX90640_SynchFrame(uint8_t slaveAddr); int MLX90640_TriggerMeasurement(uint8_t slaveAddr); int MLX90640_GetFrameData(uint8_t slaveAddr, uint16_t *frameData); int MLX90640_ExtractParameters(uint16_t *eeData, paramsMLX90640 *mlx90640); float MLX90640_GetVdd(uint16_t *frameData, const paramsMLX90640 *params); float MLX90640_GetTa(uint16_t *frameData, const paramsMLX90640 *params); void MLX90640_GetImage(uint16_t *frameData, const paramsMLX90640 *params, float *result); void MLX90640_CalculateTo(uint16_t *frameData, const paramsMLX90640 *params, float emissivity, float tr, float *result); int MLX90640_SetResolution(uint8_t slaveAddr, uint8_t resolution); int MLX90640_GetCurResolution(uint8_t slaveAddr); int MLX90640_SetRefreshRate(uint8_t slaveAddr, uint8_t refreshRate); int MLX90640_GetRefreshRate(uint8_t slaveAddr); int MLX90640_GetSubPageNumber(uint16_t *frameData); int MLX90640_GetCurMode(uint8_t slaveAddr); int MLX90640_SetInterleavedMode(uint8_t slaveAddr); int MLX90640_SetChessMode(uint8_t slaveAddr); void MLX90640_BadPixelsCorrection(uint16_t *pixels, float *to, int mode, paramsMLX90640 *params); #endif MLX90640_API.c12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319132013211322132313241325132613271328132913301331133213331334133513361337133813391340134113421343134413451346134713481349135013511352135313541355135613571358135913601361136213631364136513661367136813691370137113721373137413751376137713781379138013811382138313841385138613871388138913901391139213931394139513961397139813991400140114021403140414051406140714081409141014111412141314141415141614171418141914201421142214231424142514261427142814291430143114321433143414351436143714381439144014411442144314441445144614471448144914501451145214531454145514561457/** * @copyright (C) 2017 Melexis N.V. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * */#include &lt;MLX90640_I2C_Driver.h&gt;#include &lt;MLX90640_API.h&gt;#include &lt;math.h&gt;static void ExtractVDDParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractPTATParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractGainParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractTgcParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractResolutionParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractKsTaParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractKsToParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractAlphaParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractOffsetParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractKtaPixelParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractKvPixelParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractCPParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static void ExtractCILCParameters(uint16_t *eeData, paramsMLX90640 *mlx90640);static int ExtractDeviatingPixels(uint16_t *eeData, paramsMLX90640 *mlx90640);static int CheckAdjacentPixels(uint16_t pix1, uint16_t pix2); static float GetMedian(float *values, int n);static int IsPixelBad(uint16_t pixel,paramsMLX90640 *params);static int ValidateFrameData(uint16_t *frameData);static int ValidateAuxData(uint16_t *auxData); int MLX90640_DumpEE(uint8_t slaveAddr, uint16_t *eeData)&#123; return MLX90640_I2CRead(slaveAddr, MLX90640_EEPROM_START_ADDRESS, MLX90640_EEPROM_DUMP_NUM, eeData);&#125;int MLX90640_SynchFrame(uint8_t slaveAddr)&#123; uint16_t dataReady = 0; uint16_t statusRegister; int error = 1; error = MLX90640_I2CWrite(slaveAddr, MLX90640_STATUS_REG, MLX90640_INIT_STATUS_VALUE); if(error == -MLX90640_I2C_NACK_ERROR) &#123; return error; &#125; while(dataReady == 0) &#123; error = MLX90640_I2CRead(slaveAddr, MLX90640_STATUS_REG, 1, &amp;statusRegister); if(error != MLX90640_NO_ERROR) &#123; return error; &#125; //dataReady = statusRegister &amp; 0x0008; dataReady = MLX90640_GET_DATA_READY(statusRegister); &#125; return MLX90640_NO_ERROR; &#125;int MLX90640_TriggerMeasurement(uint8_t slaveAddr)&#123; int error = 1; uint16_t ctrlReg; error = MLX90640_I2CRead(slaveAddr, MLX90640_CTRL_REG, 1, &amp;ctrlReg); if ( error != MLX90640_NO_ERROR) &#123; return error; &#125; ctrlReg |= MLX90640_CTRL_TRIG_READY_MASK; error = MLX90640_I2CWrite(slaveAddr, MLX90640_CTRL_REG, ctrlReg); if ( error != MLX90640_NO_ERROR) &#123; return error; &#125; error = MLX90640_I2CGeneralReset(); if ( error != MLX90640_NO_ERROR) &#123; return error; &#125; error = MLX90640_I2CRead(slaveAddr, MLX90640_CTRL_REG, 1, &amp;ctrlReg); if ( error != MLX90640_NO_ERROR) &#123; return error; &#125; if ((ctrlReg &amp; MLX90640_CTRL_TRIG_READY_MASK) != 0) &#123; return -MLX90640_MEAS_TRIGGER_ERROR; &#125; return MLX90640_NO_ERROR; &#125; int MLX90640_GetFrameData(uint8_t slaveAddr, uint16_t *frameData)&#123; uint16_t dataReady = 0; uint16_t controlRegister1; uint16_t statusRegister; int error = 1; uint16_t data[64]; uint8_t cnt = 0; while(dataReady == 0) &#123; error = MLX90640_I2CRead(slaveAddr, MLX90640_STATUS_REG, 1, &amp;statusRegister); if(error != MLX90640_NO_ERROR) &#123; return error; &#125; //dataReady = statusRegister &amp; 0x0008; dataReady = MLX90640_GET_DATA_READY(statusRegister); &#125; error = MLX90640_I2CWrite(slaveAddr, MLX90640_STATUS_REG, MLX90640_INIT_STATUS_VALUE); if(error == -MLX90640_I2C_NACK_ERROR) &#123; return error; &#125; error = MLX90640_I2CRead(slaveAddr, MLX90640_PIXEL_DATA_START_ADDRESS, MLX90640_PIXEL_NUM, frameData); if(error != MLX90640_NO_ERROR) &#123; return error; &#125; error = MLX90640_I2CRead(slaveAddr, MLX90640_AUX_DATA_START_ADDRESS, MLX90640_AUX_NUM, data); if(error != MLX90640_NO_ERROR) &#123; return error; &#125; error = MLX90640_I2CRead(slaveAddr, MLX90640_CTRL_REG, 1, &amp;controlRegister1); frameData[832] = controlRegister1; //frameData[833] = statusRegister &amp; 0x0001; frameData[833] = MLX90640_GET_FRAME(statusRegister); if(error != MLX90640_NO_ERROR) &#123; return error; &#125; error = ValidateAuxData(data); if(error == MLX90640_NO_ERROR) &#123; for(cnt=0; cnt&lt;MLX90640_AUX_NUM; cnt++) &#123; frameData[cnt+MLX90640_PIXEL_NUM] = data[cnt]; &#125; &#125; error = ValidateFrameData(frameData); if (error != MLX90640_NO_ERROR) &#123; return error; &#125; return frameData[833]; &#125;static int ValidateFrameData(uint16_t *frameData)&#123; uint8_t line = 0; for(int i=0; i&lt;MLX90640_PIXEL_NUM; i+=MLX90640_LINE_SIZE) &#123; if((frameData[i] == 0x7FFF) &amp;&amp; (line%2 == frameData[833])) return -MLX90640_FRAME_DATA_ERROR; line = line + 1; &#125; return MLX90640_NO_ERROR; &#125;static int ValidateAuxData(uint16_t *auxData)&#123; if(auxData[0] == 0x7FFF) return -MLX90640_FRAME_DATA_ERROR; for(int i=8; i&lt;19; i++) &#123; if(auxData[i] == 0x7FFF) return -MLX90640_FRAME_DATA_ERROR; &#125; for(int i=20; i&lt;23; i++) &#123; if(auxData[i] == 0x7FFF) return -MLX90640_FRAME_DATA_ERROR; &#125; for(int i=24; i&lt;33; i++) &#123; if(auxData[i] == 0x7FFF) return -MLX90640_FRAME_DATA_ERROR; &#125; for(int i=40; i&lt;51; i++) &#123; if(auxData[i] == 0x7FFF) return -MLX90640_FRAME_DATA_ERROR; &#125; for(int i=52; i&lt;55; i++) &#123; if(auxData[i] == 0x7FFF) return -MLX90640_FRAME_DATA_ERROR; &#125; for(int i=56; i&lt;64; i++) &#123; if(auxData[i] == 0x7FFF) return -MLX90640_FRAME_DATA_ERROR; &#125; return MLX90640_NO_ERROR; &#125; int MLX90640_ExtractParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; int error = 0; ExtractVDDParameters(eeData, mlx90640); ExtractPTATParameters(eeData, mlx90640); ExtractGainParameters(eeData, mlx90640); ExtractTgcParameters(eeData, mlx90640); ExtractResolutionParameters(eeData, mlx90640); ExtractKsTaParameters(eeData, mlx90640); ExtractKsToParameters(eeData, mlx90640); ExtractCPParameters(eeData, mlx90640); ExtractAlphaParameters(eeData, mlx90640); ExtractOffsetParameters(eeData, mlx90640); ExtractKtaPixelParameters(eeData, mlx90640); ExtractKvPixelParameters(eeData, mlx90640); ExtractCILCParameters(eeData, mlx90640); error = ExtractDeviatingPixels(eeData, mlx90640); return error;&#125;//------------------------------------------------------------------------------int MLX90640_SetResolution(uint8_t slaveAddr, uint8_t resolution)&#123; uint16_t controlRegister1; uint16_t value; int error; //value = (resolution &amp; 0x03) &lt;&lt; 10; value = ((uint16_t)resolution &lt;&lt; MLX90640_CTRL_RESOLUTION_SHIFT); value &amp;= ~MLX90640_CTRL_RESOLUTION_MASK; error = MLX90640_I2CRead(slaveAddr, MLX90640_CTRL_REG, 1, &amp;controlRegister1); if(error == MLX90640_NO_ERROR) &#123; value = (controlRegister1 &amp; MLX90640_CTRL_RESOLUTION_MASK) | value; error = MLX90640_I2CWrite(slaveAddr, MLX90640_CTRL_REG, value); &#125; return error;&#125;//------------------------------------------------------------------------------int MLX90640_GetCurResolution(uint8_t slaveAddr)&#123; uint16_t controlRegister1; int resolutionRAM; int error; error = MLX90640_I2CRead(slaveAddr, MLX90640_CTRL_REG, 1, &amp;controlRegister1); if(error != MLX90640_NO_ERROR) &#123; return error; &#125; resolutionRAM = (controlRegister1 &amp; ~MLX90640_CTRL_RESOLUTION_MASK) &gt;&gt; MLX90640_CTRL_RESOLUTION_SHIFT; return resolutionRAM; &#125;//------------------------------------------------------------------------------int MLX90640_SetRefreshRate(uint8_t slaveAddr, uint8_t refreshRate)&#123; uint16_t controlRegister1; uint16_t value; int error; //value = (refreshRate &amp; 0x07)&lt;&lt;7; value = ((uint16_t)refreshRate &lt;&lt; MLX90640_CTRL_REFRESH_SHIFT); value &amp;= ~MLX90640_CTRL_REFRESH_MASK; error = MLX90640_I2CRead(slaveAddr, MLX90640_CTRL_REG, 1, &amp;controlRegister1); if(error == MLX90640_NO_ERROR) &#123; value = (controlRegister1 &amp; MLX90640_CTRL_REFRESH_MASK) | value; error = MLX90640_I2CWrite(slaveAddr, MLX90640_CTRL_REG, value); &#125; return error;&#125;//------------------------------------------------------------------------------int MLX90640_GetRefreshRate(uint8_t slaveAddr)&#123; uint16_t controlRegister1; int refreshRate; int error; error = MLX90640_I2CRead(slaveAddr, MLX90640_CTRL_REG, 1, &amp;controlRegister1); if(error != MLX90640_NO_ERROR) &#123; return error; &#125; refreshRate = (controlRegister1 &amp; ~MLX90640_CTRL_REFRESH_MASK) &gt;&gt; MLX90640_CTRL_REFRESH_SHIFT; return refreshRate;&#125;//------------------------------------------------------------------------------int MLX90640_SetInterleavedMode(uint8_t slaveAddr)&#123; uint16_t controlRegister1; uint16_t value; int error; error = MLX90640_I2CRead(slaveAddr, MLX90640_CTRL_REG, 1, &amp;controlRegister1); if(error == 0) &#123; value = (controlRegister1 &amp; ~MLX90640_CTRL_MEAS_MODE_MASK); error = MLX90640_I2CWrite(slaveAddr, MLX90640_CTRL_REG, value); &#125; return error;&#125;//------------------------------------------------------------------------------int MLX90640_SetChessMode(uint8_t slaveAddr)&#123; uint16_t controlRegister1; uint16_t value; int error; error = MLX90640_I2CRead(slaveAddr, MLX90640_CTRL_REG, 1, &amp;controlRegister1); if(error == 0) &#123; value = (controlRegister1 | MLX90640_CTRL_MEAS_MODE_MASK); error = MLX90640_I2CWrite(slaveAddr, MLX90640_CTRL_REG, value); &#125; return error;&#125;//------------------------------------------------------------------------------int MLX90640_GetCurMode(uint8_t slaveAddr)&#123; uint16_t controlRegister1; int modeRAM; int error; error = MLX90640_I2CRead(slaveAddr, MLX90640_CTRL_REG, 1, &amp;controlRegister1); if(error != 0) &#123; return error; &#125; modeRAM = (controlRegister1 &amp; MLX90640_CTRL_MEAS_MODE_MASK) &gt;&gt; MLX90640_CTRL_MEAS_MODE_SHIFT; return modeRAM; &#125;//------------------------------------------------------------------------------void MLX90640_CalculateTo(uint16_t *frameData, const paramsMLX90640 *params, float emissivity, float tr, float *result)&#123; float vdd; float ta; float ta4; float tr4; float taTr; float gain; float irDataCP[2]; float irData; float alphaCompensated; uint8_t mode; int8_t ilPattern; int8_t chessPattern; int8_t pattern; int8_t conversionPattern; float Sx; float To; float alphaCorrR[4]; int8_t range; uint16_t subPage; float ktaScale; float kvScale; float alphaScale; float kta; float kv; subPage = frameData[833]; vdd = MLX90640_GetVdd(frameData, params); ta = MLX90640_GetTa(frameData, params); ta4 = (ta + 273.15); ta4 = ta4 * ta4; ta4 = ta4 * ta4; tr4 = (tr + 273.15); tr4 = tr4 * tr4; tr4 = tr4 * tr4; taTr = tr4 - (tr4-ta4)/emissivity; ktaScale = POW2(params-&gt;ktaScale); kvScale = POW2(params-&gt;kvScale); alphaScale = POW2(params-&gt;alphaScale); alphaCorrR[0] = 1 / (1 + params-&gt;ksTo[0] * 40); alphaCorrR[1] = 1 ; alphaCorrR[2] = (1 + params-&gt;ksTo[1] * params-&gt;ct[2]); alphaCorrR[3] = alphaCorrR[2] * (1 + params-&gt;ksTo[2] * (params-&gt;ct[3] - params-&gt;ct[2])); //------------------------- Gain calculation ----------------------------------- gain = (float)params-&gt;gainEE / (int16_t)frameData[778]; //------------------------- To calculation ------------------------------------- mode = (frameData[832] &amp; MLX90640_CTRL_MEAS_MODE_MASK) &gt;&gt; 5; irDataCP[0] = (int16_t)frameData[776] * gain; irDataCP[1] = (int16_t)frameData[808] * gain; irDataCP[0] = irDataCP[0] - params-&gt;cpOffset[0] * (1 + params-&gt;cpKta * (ta - 25)) * (1 + params-&gt;cpKv * (vdd - 3.3)); if( mode == params-&gt;calibrationModeEE) &#123; irDataCP[1] = irDataCP[1] - params-&gt;cpOffset[1] * (1 + params-&gt;cpKta * (ta - 25)) * (1 + params-&gt;cpKv * (vdd - 3.3)); &#125; else &#123; irDataCP[1] = irDataCP[1] - (params-&gt;cpOffset[1] + params-&gt;ilChessC[0]) * (1 + params-&gt;cpKta * (ta - 25)) * (1 + params-&gt;cpKv * (vdd - 3.3)); &#125; for( int pixelNumber = 0; pixelNumber &lt; 768; pixelNumber++) &#123; ilPattern = pixelNumber / 32 - (pixelNumber / 64) * 2; chessPattern = ilPattern ^ (pixelNumber - (pixelNumber/2)*2); conversionPattern = ((pixelNumber + 2) / 4 - (pixelNumber + 3) / 4 + (pixelNumber + 1) / 4 - pixelNumber / 4) * (1 - 2 * ilPattern); if(mode == 0) &#123; pattern = ilPattern; &#125; else &#123; pattern = chessPattern; &#125; if(pattern == frameData[833]) &#123; irData = (int16_t)frameData[pixelNumber] * gain; kta = params-&gt;kta[pixelNumber]/ktaScale; kv = params-&gt;kv[pixelNumber]/kvScale; irData = irData - params-&gt;offset[pixelNumber]*(1 + kta*(ta - 25))*(1 + kv*(vdd - 3.3)); if(mode != params-&gt;calibrationModeEE) &#123; irData = irData + params-&gt;ilChessC[2] * (2 * ilPattern - 1) - params-&gt;ilChessC[1] * conversionPattern; &#125; irData = irData - params-&gt;tgc * irDataCP[subPage]; irData = irData / emissivity; alphaCompensated = SCALEALPHA*alphaScale/params-&gt;alpha[pixelNumber]; alphaCompensated = alphaCompensated*(1 + params-&gt;KsTa * (ta - 25)); Sx = alphaCompensated * alphaCompensated * alphaCompensated * (irData + alphaCompensated * taTr); Sx = sqrt(sqrt(Sx)) * params-&gt;ksTo[1]; To = sqrt(sqrt(irData/(alphaCompensated * (1 - params-&gt;ksTo[1] * 273.15) + Sx) + taTr)) - 273.15; if(To &lt; params-&gt;ct[1]) &#123; range = 0; &#125; else if(To &lt; params-&gt;ct[2]) &#123; range = 1; &#125; else if(To &lt; params-&gt;ct[3]) &#123; range = 2; &#125; else &#123; range = 3; &#125; To = sqrt(sqrt(irData / (alphaCompensated * alphaCorrR[range] * (1 + params-&gt;ksTo[range] * (To - params-&gt;ct[range]))) + taTr)) - 273.15; result[pixelNumber] = To; &#125; &#125;&#125;//------------------------------------------------------------------------------void MLX90640_GetImage(uint16_t *frameData, const paramsMLX90640 *params, float *result)&#123; float vdd; float ta; float gain; float irDataCP[2]; float irData; float alphaCompensated; uint8_t mode; int8_t ilPattern; int8_t chessPattern; int8_t pattern; int8_t conversionPattern; float image; uint16_t subPage; float ktaScale; float kvScale; float kta; float kv; subPage = frameData[833]; vdd = MLX90640_GetVdd(frameData, params); ta = MLX90640_GetTa(frameData, params); ktaScale = POW2(params-&gt;ktaScale); kvScale = POW2(params-&gt;kvScale); //------------------------- Gain calculation ----------------------------------- gain = (float)params-&gt;gainEE / (int16_t)frameData[778]; //------------------------- Image calculation ------------------------------------- mode = (frameData[832] &amp; MLX90640_CTRL_MEAS_MODE_MASK) &gt;&gt; 5; irDataCP[0] = (int16_t)frameData[776] * gain; irDataCP[1] = (int16_t)frameData[808] * gain; irDataCP[0] = irDataCP[0] - params-&gt;cpOffset[0] * (1 + params-&gt;cpKta * (ta - 25)) * (1 + params-&gt;cpKv * (vdd - 3.3)); if( mode == params-&gt;calibrationModeEE) &#123; irDataCP[1] = irDataCP[1] - params-&gt;cpOffset[1] * (1 + params-&gt;cpKta * (ta - 25)) * (1 + params-&gt;cpKv * (vdd - 3.3)); &#125; else &#123; irDataCP[1] = irDataCP[1] - (params-&gt;cpOffset[1] + params-&gt;ilChessC[0]) * (1 + params-&gt;cpKta * (ta - 25)) * (1 + params-&gt;cpKv * (vdd - 3.3)); &#125; for( int pixelNumber = 0; pixelNumber &lt; 768; pixelNumber++) &#123; ilPattern = pixelNumber / 32 - (pixelNumber / 64) * 2; chessPattern = ilPattern ^ (pixelNumber - (pixelNumber/2)*2); conversionPattern = ((pixelNumber + 2) / 4 - (pixelNumber + 3) / 4 + (pixelNumber + 1) / 4 - pixelNumber / 4) * (1 - 2 * ilPattern); if(mode == 0) &#123; pattern = ilPattern; &#125; else &#123; pattern = chessPattern; &#125; if(pattern == frameData[833]) &#123; irData = (int16_t)frameData[pixelNumber] * gain; kta = params-&gt;kta[pixelNumber]/ktaScale; kv = params-&gt;kv[pixelNumber]/kvScale; irData = irData - params-&gt;offset[pixelNumber]*(1 + kta*(ta - 25))*(1 + kv*(vdd - 3.3)); if(mode != params-&gt;calibrationModeEE) &#123; irData = irData + params-&gt;ilChessC[2] * (2 * ilPattern - 1) - params-&gt;ilChessC[1] * conversionPattern; &#125; irData = irData - params-&gt;tgc * irDataCP[subPage]; alphaCompensated = params-&gt;alpha[pixelNumber]; image = irData*alphaCompensated; result[pixelNumber] = image; &#125; &#125;&#125;//------------------------------------------------------------------------------float MLX90640_GetVdd(uint16_t *frameData, const paramsMLX90640 *params)&#123; float vdd; float resolutionCorrection; uint16_t resolutionRAM; resolutionRAM = (frameData[832] &amp; ~MLX90640_CTRL_RESOLUTION_MASK) &gt;&gt; MLX90640_CTRL_RESOLUTION_SHIFT; resolutionCorrection = POW2(params-&gt;resolutionEE) / POW2(resolutionRAM); vdd = (resolutionCorrection * (int16_t)frameData[810] - params-&gt;vdd25) / params-&gt;kVdd + 3.3; return vdd;&#125;//------------------------------------------------------------------------------float MLX90640_GetTa(uint16_t *frameData, const paramsMLX90640 *params)&#123; int16_t ptat; float ptatArt; float vdd; float ta; vdd = MLX90640_GetVdd(frameData, params); ptat = (int16_t)frameData[800]; ptatArt = (ptat / (ptat * params-&gt;alphaPTAT + (int16_t)frameData[768])) * POW2(18); ta = (ptatArt / (1 + params-&gt;KvPTAT * (vdd - 3.3)) - params-&gt;vPTAT25); ta = ta / params-&gt;KtPTAT + 25; return ta;&#125;//------------------------------------------------------------------------------int MLX90640_GetSubPageNumber(uint16_t *frameData)&#123; return frameData[833]; &#125; //------------------------------------------------------------------------------void MLX90640_BadPixelsCorrection(uint16_t *pixels, float *to, int mode, paramsMLX90640 *params)&#123; float ap[4]; uint8_t pix; uint8_t line; uint8_t column; pix = 0; while(pixels[pix] != 0xFFFF) &#123; line = pixels[pix]&gt;&gt;5; column = pixels[pix] - (line&lt;&lt;5); if(mode == 1) &#123; if(line == 0) &#123; if(column == 0) &#123; to[pixels[pix]] = to[33]; &#125; else if(column == 31) &#123; to[pixels[pix]] = to[62]; &#125; else &#123; to[pixels[pix]] = (to[pixels[pix]+31] + to[pixels[pix]+33])/2.0; &#125; &#125; else if(line == 23) &#123; if(column == 0) &#123; to[pixels[pix]] = to[705]; &#125; else if(column == 31) &#123; to[pixels[pix]] = to[734]; &#125; else &#123; to[pixels[pix]] = (to[pixels[pix]-33] + to[pixels[pix]-31])/2.0; &#125; &#125; else if(column == 0) &#123; to[pixels[pix]] = (to[pixels[pix]-31] + to[pixels[pix]+33])/2.0; &#125; else if(column == 31) &#123; to[pixels[pix]] = (to[pixels[pix]-33] + to[pixels[pix]+31])/2.0; &#125; else &#123; ap[0] = to[pixels[pix]-33]; ap[1] = to[pixels[pix]-31]; ap[2] = to[pixels[pix]+31]; ap[3] = to[pixels[pix]+33]; to[pixels[pix]] = GetMedian(ap,4); &#125; &#125; else &#123; if(column == 0) &#123; to[pixels[pix]] = to[pixels[pix]+1]; &#125; else if(column == 1 || column == 30) &#123; to[pixels[pix]] = (to[pixels[pix]-1]+to[pixels[pix]+1])/2.0; &#125; else if(column == 31) &#123; to[pixels[pix]] = to[pixels[pix]-1]; &#125; else &#123; if(IsPixelBad(pixels[pix]-2,params) == 0 &amp;&amp; IsPixelBad(pixels[pix]+2,params) == 0) &#123; ap[0] = to[pixels[pix]+1] - to[pixels[pix]+2]; ap[1] = to[pixels[pix]-1] - to[pixels[pix]-2]; if(fabs(ap[0]) &gt; fabs(ap[1])) &#123; to[pixels[pix]] = to[pixels[pix]-1] + ap[1]; &#125; else &#123; to[pixels[pix]] = to[pixels[pix]+1] + ap[0]; &#125; &#125; else &#123; to[pixels[pix]] = (to[pixels[pix]-1]+to[pixels[pix]+1])/2.0; &#125; &#125; &#125; pix = pix + 1; &#125; &#125;//------------------------------------------------------------------------------static void ExtractVDDParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; int8_t kVdd; int16_t vdd25; kVdd = MLX90640_MS_BYTE(eeData[51]); vdd25 = MLX90640_LS_BYTE(eeData[51]); vdd25 = ((vdd25 - 256) &lt;&lt; 5) - 8192; mlx90640-&gt;kVdd = 32 * kVdd; mlx90640-&gt;vdd25 = vdd25; &#125;//------------------------------------------------------------------------------static void ExtractPTATParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; float KvPTAT; float KtPTAT; int16_t vPTAT25; float alphaPTAT; KvPTAT = (eeData[50] &amp; MLX90640_MSBITS_6_MASK) &gt;&gt; 10; if(KvPTAT &gt; 31) &#123; KvPTAT = KvPTAT - 64; &#125; KvPTAT = KvPTAT/4096; KtPTAT = eeData[50] &amp; MLX90640_LSBITS_10_MASK; if(KtPTAT &gt; 511) &#123; KtPTAT = KtPTAT - 1024; &#125; KtPTAT = KtPTAT/8; vPTAT25 = eeData[49]; alphaPTAT = (eeData[16] &amp; MLX90640_NIBBLE4_MASK) / POW2(14) + 8.0f; mlx90640-&gt;KvPTAT = KvPTAT; mlx90640-&gt;KtPTAT = KtPTAT; mlx90640-&gt;vPTAT25 = vPTAT25; mlx90640-&gt;alphaPTAT = alphaPTAT; &#125;//------------------------------------------------------------------------------static void ExtractGainParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; mlx90640-&gt;gainEE = (int16_t)eeData[48];; &#125;//------------------------------------------------------------------------------static void ExtractTgcParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; mlx90640-&gt;tgc = (int8_t)MLX90640_LS_BYTE(eeData[60]) / 32.0f;&#125;//------------------------------------------------------------------------------static void ExtractResolutionParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; uint8_t resolutionEE; resolutionEE = (eeData[56] &amp; 0x3000) &gt;&gt; 12; mlx90640-&gt;resolutionEE = resolutionEE;&#125;//------------------------------------------------------------------------------static void ExtractKsTaParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; mlx90640-&gt;KsTa = (int8_t)MLX90640_MS_BYTE(eeData[60]) / 8192.0f;&#125;//------------------------------------------------------------------------------static void ExtractKsToParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; int32_t KsToScale; int8_t step; step = ((eeData[63] &amp; 0x3000) &gt;&gt; 12) * 10; mlx90640-&gt;ct[0] = -40; mlx90640-&gt;ct[1] = 0; mlx90640-&gt;ct[2] = MLX90640_NIBBLE2(eeData[63]); mlx90640-&gt;ct[3] = MLX90640_NIBBLE3(eeData[63]); mlx90640-&gt;ct[2] = mlx90640-&gt;ct[2]*step; mlx90640-&gt;ct[3] = mlx90640-&gt;ct[2] + mlx90640-&gt;ct[3]*step; mlx90640-&gt;ct[4] = 400; KsToScale = MLX90640_NIBBLE1(eeData[63]) + 8; KsToScale = 1UL &lt;&lt; KsToScale; mlx90640-&gt;ksTo[0] = (int8_t)MLX90640_LS_BYTE(eeData[61]) / (float)KsToScale; mlx90640-&gt;ksTo[1] = (int8_t)MLX90640_MS_BYTE(eeData[61]) / (float)KsToScale; mlx90640-&gt;ksTo[2] = (int8_t)MLX90640_LS_BYTE(eeData[62]) / (float)KsToScale; mlx90640-&gt;ksTo[3] = (int8_t)MLX90640_MS_BYTE(eeData[62]) / (float)KsToScale; mlx90640-&gt;ksTo[4] = -0.0002;&#125;//------------------------------------------------------------------------------static void ExtractAlphaParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; int accRow[24]; int accColumn[32]; int p = 0; int alphaRef; uint8_t alphaScale; uint8_t accRowScale; uint8_t accColumnScale; uint8_t accRemScale; float alphaTemp[768]; float temp; accRemScale = MLX90640_NIBBLE1(eeData[32]); accColumnScale = MLX90640_NIBBLE2(eeData[32]); accRowScale = MLX90640_NIBBLE3(eeData[32]); alphaScale = MLX90640_NIBBLE4(eeData[32]) + 30; alphaRef = eeData[33]; for(int i = 0; i &lt; 6; i++) &#123; p = i * 4; accRow[p + 0] = MLX90640_NIBBLE1(eeData[34 + i]); accRow[p + 1] = MLX90640_NIBBLE2(eeData[34 + i]); accRow[p + 2] = MLX90640_NIBBLE3(eeData[34 + i]); accRow[p + 3] = MLX90640_NIBBLE4(eeData[34 + i]); &#125; for(int i = 0; i &lt; MLX90640_LINE_NUM; i++) &#123; if (accRow[i] &gt; 7) &#123; accRow[i] = accRow[i] - 16; &#125; &#125; for(int i = 0; i &lt; 8; i++) &#123; p = i * 4; accColumn[p + 0] = MLX90640_NIBBLE1(eeData[40 + i]); accColumn[p + 1] = MLX90640_NIBBLE2(eeData[40 + i]); accColumn[p + 2] = MLX90640_NIBBLE3(eeData[40 + i]); accColumn[p + 3] = MLX90640_NIBBLE4(eeData[40 + i]); &#125; for(int i = 0; i &lt; MLX90640_COLUMN_NUM; i++) &#123; if (accColumn[i] &gt; 7) &#123; accColumn[i] = accColumn[i] - 16; &#125; &#125; for(int i = 0; i &lt; MLX90640_LINE_NUM; i++) &#123; for(int j = 0; j &lt; MLX90640_COLUMN_NUM; j ++) &#123; p = 32 * i +j; alphaTemp[p] = (eeData[64 + p] &amp; 0x03F0) &gt;&gt; 4; if (alphaTemp[p] &gt; 31) &#123; alphaTemp[p] = alphaTemp[p] - 64; &#125; alphaTemp[p] = alphaTemp[p]*(1 &lt;&lt; accRemScale); alphaTemp[p] = (alphaRef + (accRow[i] &lt;&lt; accRowScale) + (accColumn[j] &lt;&lt; accColumnScale) + alphaTemp[p]); alphaTemp[p] = alphaTemp[p] / POW2(alphaScale); alphaTemp[p] = alphaTemp[p] - mlx90640-&gt;tgc * (mlx90640-&gt;cpAlpha[0] + mlx90640-&gt;cpAlpha[1])/2; alphaTemp[p] = SCALEALPHA/alphaTemp[p]; &#125; &#125; temp = alphaTemp[0]; for(int i = 1; i &lt; MLX90640_PIXEL_NUM; i++) &#123; if (alphaTemp[i] &gt; temp) &#123; temp = alphaTemp[i]; &#125; &#125; alphaScale = 0; while(temp &lt; 32767.4) &#123; temp = temp*2; alphaScale = alphaScale + 1; &#125; for(int i = 0; i &lt; MLX90640_PIXEL_NUM; i++) &#123; temp = alphaTemp[i] * POW2(alphaScale); mlx90640-&gt;alpha[i] = (temp + 0.5); &#125; mlx90640-&gt;alphaScale = alphaScale; &#125;//------------------------------------------------------------------------------static void ExtractOffsetParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; int occRow[24]; int occColumn[32]; int p = 0; int16_t offsetRef; uint8_t occRowScale; uint8_t occColumnScale; uint8_t occRemScale; occRemScale = MLX90640_NIBBLE1(eeData[16]); occColumnScale = MLX90640_NIBBLE2(eeData[16]); occRowScale = MLX90640_NIBBLE3(eeData[16]); offsetRef = (int16_t)eeData[17]; for(int i = 0; i &lt; 6; i++) &#123; p = i * 4; occRow[p + 0] = MLX90640_NIBBLE1(eeData[18 + i]); occRow[p + 1] = MLX90640_NIBBLE2(eeData[18 + i]); occRow[p + 2] = MLX90640_NIBBLE3(eeData[18 + i]); occRow[p + 3] = MLX90640_NIBBLE4(eeData[18 + i]); &#125; for(int i = 0; i &lt; MLX90640_LINE_NUM; i++) &#123; if (occRow[i] &gt; 7) &#123; occRow[i] = occRow[i] - 16; &#125; &#125; for(int i = 0; i &lt; 8; i++) &#123; p = i * 4; occColumn[p + 0] = MLX90640_NIBBLE1(eeData[24 + i]); occColumn[p + 1] = MLX90640_NIBBLE2(eeData[24 + i]); occColumn[p + 2] = MLX90640_NIBBLE3(eeData[24 + i]); occColumn[p + 3] = MLX90640_NIBBLE4(eeData[24 + i]); &#125; for(int i = 0; i &lt; MLX90640_COLUMN_NUM; i ++) &#123; if (occColumn[i] &gt; 7) &#123; occColumn[i] = occColumn[i] - 16; &#125; &#125; for(int i = 0; i &lt; MLX90640_LINE_NUM; i++) &#123; for(int j = 0; j &lt; MLX90640_COLUMN_NUM; j ++) &#123; p = 32 * i +j; mlx90640-&gt;offset[p] = (eeData[64 + p] &amp; MLX90640_MSBITS_6_MASK) &gt;&gt; 10; if (mlx90640-&gt;offset[p] &gt; 31) &#123; mlx90640-&gt;offset[p] = mlx90640-&gt;offset[p] - 64; &#125; mlx90640-&gt;offset[p] = mlx90640-&gt;offset[p]*(1 &lt;&lt; occRemScale); mlx90640-&gt;offset[p] = (offsetRef + (occRow[i] &lt;&lt; occRowScale) + (occColumn[j] &lt;&lt; occColumnScale) + mlx90640-&gt;offset[p]); &#125; &#125;&#125;//------------------------------------------------------------------------------static void ExtractKtaPixelParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; int p = 0; int8_t KtaRC[4]; uint8_t ktaScale1; uint8_t ktaScale2; uint8_t split; float ktaTemp[768]; float temp; KtaRC[0] = (int8_t)MLX90640_MS_BYTE(eeData[54]);; KtaRC[2] = (int8_t)MLX90640_LS_BYTE(eeData[54]);; KtaRC[1] = (int8_t)MLX90640_MS_BYTE(eeData[55]);; KtaRC[3] = (int8_t)MLX90640_LS_BYTE(eeData[55]);; ktaScale1 = MLX90640_NIBBLE2(eeData[56]) + 8; ktaScale2 = MLX90640_NIBBLE1(eeData[56]); for(int i = 0; i &lt; MLX90640_LINE_NUM; i++) &#123; for(int j = 0; j &lt; MLX90640_COLUMN_NUM; j ++) &#123; p = 32 * i +j; split = 2*(p/32 - (p/64)*2) + p%2; ktaTemp[p] = (eeData[64 + p] &amp; 0x000E) &gt;&gt; 1; if (ktaTemp[p] &gt; 3) &#123; ktaTemp[p] = ktaTemp[p] - 8; &#125; ktaTemp[p] = ktaTemp[p] * (1 &lt;&lt; ktaScale2); ktaTemp[p] = KtaRC[split] + ktaTemp[p]; ktaTemp[p] = ktaTemp[p] / POW2(ktaScale1); &#125; &#125; temp = fabs(ktaTemp[0]); for(int i = 1; i &lt; MLX90640_PIXEL_NUM; i++) &#123; if (fabs(ktaTemp[i]) &gt; temp) &#123; temp = fabs(ktaTemp[i]); &#125; &#125; ktaScale1 = 0; while(temp &lt; 63.4) &#123; temp = temp*2; ktaScale1 = ktaScale1 + 1; &#125; for(int i = 0; i &lt; MLX90640_PIXEL_NUM; i++) &#123; temp = ktaTemp[i] * POW2(ktaScale1); if (temp &lt; 0) &#123; mlx90640-&gt;kta[i] = (temp - 0.5); &#125; else &#123; mlx90640-&gt;kta[i] = (temp + 0.5); &#125; &#125; mlx90640-&gt;ktaScale = ktaScale1; &#125;//------------------------------------------------------------------------------static void ExtractKvPixelParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; int p = 0; int8_t KvT[4]; int8_t KvRoCo; int8_t KvRoCe; int8_t KvReCo; int8_t KvReCe; uint8_t kvScale; uint8_t split; float kvTemp[768]; float temp; KvRoCo = MLX90640_NIBBLE4(eeData[52]); if (KvRoCo &gt; 7) &#123; KvRoCo = KvRoCo - 16; &#125; KvT[0] = KvRoCo; KvReCo = MLX90640_NIBBLE3(eeData[52]); if (KvReCo &gt; 7) &#123; KvReCo = KvReCo - 16; &#125; KvT[2] = KvReCo; KvRoCe = MLX90640_NIBBLE2(eeData[52]); if (KvRoCe &gt; 7) &#123; KvRoCe = KvRoCe - 16; &#125; KvT[1] = KvRoCe; KvReCe = MLX90640_NIBBLE1(eeData[52]); if (KvReCe &gt; 7) &#123; KvReCe = KvReCe - 16; &#125; KvT[3] = KvReCe; kvScale = MLX90640_NIBBLE3(eeData[56]); for(int i = 0; i &lt; MLX90640_LINE_NUM; i++) &#123; for(int j = 0; j &lt; MLX90640_COLUMN_NUM; j ++) &#123; p = 32 * i +j; split = 2*(p/32 - (p/64)*2) + p%2; kvTemp[p] = KvT[split]; kvTemp[p] = kvTemp[p] / POW2(kvScale); &#125; &#125; temp = fabs(kvTemp[0]); for(int i = 1; i &lt; MLX90640_PIXEL_NUM; i++) &#123; if (fabs(kvTemp[i]) &gt; temp) &#123; temp = fabs(kvTemp[i]); &#125; &#125; kvScale = 0; while(temp &lt; 63.4) &#123; temp = temp*2; kvScale = kvScale + 1; &#125; for(int i = 0; i &lt; MLX90640_PIXEL_NUM; i++) &#123; temp = kvTemp[i] * POW2(kvScale); if (temp &lt; 0) &#123; mlx90640-&gt;kv[i] = (temp - 0.5); &#125; else &#123; mlx90640-&gt;kv[i] = (temp + 0.5); &#125; &#125; mlx90640-&gt;kvScale = kvScale; &#125;//------------------------------------------------------------------------------static void ExtractCPParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; float alphaSP[2]; int16_t offsetSP[2]; float cpKv; float cpKta; uint8_t alphaScale; uint8_t ktaScale1; uint8_t kvScale; alphaScale = MLX90640_NIBBLE4(eeData[32]) + 27; offsetSP[0] = (eeData[58] &amp; MLX90640_LSBITS_10_MASK); if (offsetSP[0] &gt; 511) &#123; offsetSP[0] = offsetSP[0] - 1024; &#125; offsetSP[1] = (eeData[58] &amp; MLX90640_MSBITS_6_MASK) &gt;&gt; 10; if (offsetSP[1] &gt; 31) &#123; offsetSP[1] = offsetSP[1] - 64; &#125; offsetSP[1] = offsetSP[1] + offsetSP[0]; alphaSP[0] = (eeData[57] &amp; MLX90640_LSBITS_10_MASK); if (alphaSP[0] &gt; 511) &#123; alphaSP[0] = alphaSP[0] - 1024; &#125; alphaSP[0] = alphaSP[0] / POW2(alphaScale); alphaSP[1] = (eeData[57] &amp; MLX90640_MSBITS_6_MASK) &gt;&gt; 10; if (alphaSP[1] &gt; 31) &#123; alphaSP[1] = alphaSP[1] - 64; &#125; alphaSP[1] = (1 + alphaSP[1]/128) * alphaSP[0]; cpKta = (int8_t)MLX90640_LS_BYTE(eeData[59]); ktaScale1 = MLX90640_NIBBLE2(eeData[56]) + 8; mlx90640-&gt;cpKta = cpKta / POW2(ktaScale1); cpKv = (int8_t)MLX90640_MS_BYTE(eeData[59]); kvScale = MLX90640_NIBBLE3(eeData[56]); mlx90640-&gt;cpKv = cpKv / POW2(kvScale); mlx90640-&gt;cpAlpha[0] = alphaSP[0]; mlx90640-&gt;cpAlpha[1] = alphaSP[1]; mlx90640-&gt;cpOffset[0] = offsetSP[0]; mlx90640-&gt;cpOffset[1] = offsetSP[1]; &#125;//------------------------------------------------------------------------------static void ExtractCILCParameters(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; float ilChessC[3]; uint8_t calibrationModeEE; calibrationModeEE = (eeData[10] &amp; 0x0800) &gt;&gt; 4; calibrationModeEE = calibrationModeEE ^ 0x80; ilChessC[0] = (eeData[53] &amp; 0x003F); if (ilChessC[0] &gt; 31) &#123; ilChessC[0] = ilChessC[0] - 64; &#125; ilChessC[0] = ilChessC[0] / 16.0f; ilChessC[1] = (eeData[53] &amp; 0x07C0) &gt;&gt; 6; if (ilChessC[1] &gt; 15) &#123; ilChessC[1] = ilChessC[1] - 32; &#125; ilChessC[1] = ilChessC[1] / 2.0f; ilChessC[2] = (eeData[53] &amp; 0xF800) &gt;&gt; 11; if (ilChessC[2] &gt; 15) &#123; ilChessC[2] = ilChessC[2] - 32; &#125; ilChessC[2] = ilChessC[2] / 8.0f; mlx90640-&gt;calibrationModeEE = calibrationModeEE; mlx90640-&gt;ilChessC[0] = ilChessC[0]; mlx90640-&gt;ilChessC[1] = ilChessC[1]; mlx90640-&gt;ilChessC[2] = ilChessC[2];&#125;//------------------------------------------------------------------------------static int ExtractDeviatingPixels(uint16_t *eeData, paramsMLX90640 *mlx90640)&#123; uint16_t pixCnt = 0; uint16_t brokenPixCnt = 0; uint16_t outlierPixCnt = 0; int warn = 0; int i; for(pixCnt = 0; pixCnt&lt;5; pixCnt++) &#123; mlx90640-&gt;brokenPixels[pixCnt] = 0xFFFF; mlx90640-&gt;outlierPixels[pixCnt] = 0xFFFF; &#125; pixCnt = 0; while (pixCnt &lt; MLX90640_PIXEL_NUM &amp;&amp; brokenPixCnt &lt; 5 &amp;&amp; outlierPixCnt &lt; 5) &#123; if(eeData[pixCnt+64] == 0) &#123; mlx90640-&gt;brokenPixels[brokenPixCnt] = pixCnt; brokenPixCnt = brokenPixCnt + 1; &#125; else if((eeData[pixCnt+64] &amp; 0x0001) != 0) &#123; mlx90640-&gt;outlierPixels[outlierPixCnt] = pixCnt; outlierPixCnt = outlierPixCnt + 1; &#125; pixCnt = pixCnt + 1; &#125; if(brokenPixCnt &gt; 4) &#123; warn = -MLX90640_BROKEN_PIXELS_NUM_ERROR; &#125; else if(outlierPixCnt &gt; 4) &#123; warn = -MLX90640_OUTLIER_PIXELS_NUM_ERROR; &#125; else if((brokenPixCnt + outlierPixCnt) &gt; 4) &#123; warn = -MLX90640_BAD_PIXELS_NUM_ERROR; &#125; else &#123; for(pixCnt=0; pixCnt&lt;brokenPixCnt; pixCnt++) &#123; for(i=pixCnt+1; i&lt;brokenPixCnt; i++) &#123; warn = CheckAdjacentPixels(mlx90640-&gt;brokenPixels[pixCnt],mlx90640-&gt;brokenPixels[i]); if(warn != 0) &#123; return warn; &#125; &#125; &#125; for(pixCnt=0; pixCnt&lt;outlierPixCnt; pixCnt++) &#123; for(i=pixCnt+1; i&lt;outlierPixCnt; i++) &#123; warn = CheckAdjacentPixels(mlx90640-&gt;outlierPixels[pixCnt],mlx90640-&gt;outlierPixels[i]); if(warn != 0) &#123; return warn; &#125; &#125; &#125; for(pixCnt=0; pixCnt&lt;brokenPixCnt; pixCnt++) &#123; for(i=0; i&lt;outlierPixCnt; i++) &#123; warn = CheckAdjacentPixels(mlx90640-&gt;brokenPixels[pixCnt],mlx90640-&gt;outlierPixels[i]); if(warn != 0) &#123; return warn; &#125; &#125; &#125; &#125; return warn; &#125;//------------------------------------------------------------------------------ static int CheckAdjacentPixels(uint16_t pix1, uint16_t pix2) &#123; int pixPosDif; uint16_t lp1 = pix1 &gt;&gt; 5; uint16_t lp2 = pix2 &gt;&gt; 5; uint16_t cp1 = pix1 - (lp1 &lt;&lt; 5); uint16_t cp2 = pix2 - (lp2 &lt;&lt; 5); pixPosDif = lp1 - lp2; if(pixPosDif &gt; -2 &amp;&amp; pixPosDif &lt; 2) &#123; pixPosDif = cp1 - cp2; if(pixPosDif &gt; -2 &amp;&amp; pixPosDif &lt; 2) &#123; return -6; &#125; &#125; return 0; &#125; //------------------------------------------------------------------------------ static float GetMedian(float *values, int n) &#123; float temp; for(int i=0; i&lt;n-1; i++) &#123; for(int j=i+1; j&lt;n; j++) &#123; if(values[j] &lt; values[i]) &#123; temp = values[i]; values[i] = values[j]; values[j] = temp; &#125; &#125; &#125; if(n%2==0) &#123; return ((values[n/2] + values[n/2 - 1]) / 2.0); &#125; else &#123; return values[n/2]; &#125; &#125; //------------------------------------------------------------------------------static int IsPixelBad(uint16_t pixel,paramsMLX90640 *params)&#123; for(int i=0; i&lt;5; i++) &#123; if(pixel == params-&gt;outlierPixels[i] || pixel == params-&gt;brokenPixels[i]) &#123; return 1; &#125; &#125; return 0; &#125; //------------------------------------------------------------------------------","categories":[],"tags":[]},{"title":"003-进程与线程","slug":"ProcessandThread","date":"2024-10-01T12:00:00.000Z","updated":"2024-10-01T13:24:45.616Z","comments":true,"path":"2024/10/01/ProcessandThread/","permalink":"https://jianghe-jnhe.github.io/2024/10/01/ProcessandThread/","excerpt":"","text":"基本概念 进程 process （Linux） 线程 thread （RT-Thread）&#x2F; 任务 task （FreeRTOS） 进程间通信 IPC （Interprocess Communication） 管道 pipe 进程间通信Linux 线程 管道 pipe 单向通信 有限缓冲区 阻塞读写 消息无类型 有序数据流 2个进程间 生产者-消费者模式 匿名管道 pipe 父-子进程间通信 命名管道 name pipe | FIFO 无亲缘关系进程间通信 消息队列 Queue 多个进程 异步通信-可非阻塞 有序发，可选择性收 持续存在 消息有类型 发布-订阅模式 链表 内存共享 Shared Memory 多个进程 无需操作系统内核-速度快 频繁传递大量数据 生产者-消费者模式 同步问题解决 信号量 semaphore 互斥锁 Mutex 类似 内存映射 Memory-mapped 文件系统 File System 套接字 Sockets 网络通信 不同主机进程间 应用于分布式系统 客户端-服务器模式 信号 Signal 软件中断 轻量级 异步 信号屏蔽-阻塞 观察者模式 | 状态机模式 线程间通信FreeRTOS RT-Tread Linux 同步与互斥 消息队列 Queue 任意类型消息 FIFO 信号量 Semaphore 解决同步问题 不存储资源 计数信号量：多线程&#x2F;任务 二值信号量：类似于互斥锁 互斥锁 Mutex 解决同步问题 阻塞（休眠） 事件组 Event Groups 解决复杂同步问题 允许任务等待 软件定时器 Timer 非阻塞 解决同步问题 通知 Notification FreeRTOS 轻量级 简单任务 效率高 邮箱 Mailbox RT-Tread 消息固定大小-类似消息队列 内存池 Memory Pool RT-Tread 内存块数据共享 效率高 条件变量 Condition Variable Linux 配合互斥锁 总结 通信方式 Linux FreeRTOS RT-Thread 消息队列 消息队列 消息队列 消息队列 邮箱 — — 邮箱 管道 管道 — 管道 共享内存 共享内存 — 内存池 信号量 信号量 信号量 信号量 互斥锁 互斥锁 互斥锁 互斥锁 条件变量 条件变量 — — 信号 信号 — 信号 通知 — 任务通知 — 事件 — 事件组 事件 中断 中断 中断 中断 软件定时器 软件定时器 软件定时器 软件定时器","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://jianghe-jnhe.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"002-字符与杂项","slug":"cdevandmisc","date":"2024-09-30T11:30:00.000Z","updated":"2024-09-30T13:52:15.836Z","comments":true,"path":"2024/09/30/cdevandmisc/","permalink":"https://jianghe-jnhe.github.io/2024/09/30/cdevandmisc/","excerpt":"","text":"基本概念 驱动 driver 开发（个人理解） 👇设备 device （&#x3D;&#x3D;对象&#x3D;&#x3D; objcet） 设备号（住址号）：区域 region ；（家庭住址，唯一性） 注册设备（属性（名字 name ）+行为&#x2F;操作 operations）：name | open relaase read write 👇设备节点 Node（&#x3D;&#x3D;类&#x3D;&#x3D; class） 👆内核kernel 有创建 create 就有销毁 destory 字符设备 字符&#x3D;&#x3D;设备号&#x3D;&#x3D;的申请 设备号类型 dev_t （无符号的 32 位整形类型 unsigned int ：高12位表示主设备号，低20位表示次设备号） 123456/* kernel/include/linux/types.h */typedef u32 __kernel_dev_t;typedef __kernel_dev_t dev_t;/* kernel/include/uapi/asm-generic/int-ll64.h */typedef unsigned int __u32; 1234567//API/* kernel/include/linux/kdev_t.h */#define MINORBITS 20 /* 次设备号位数 */#define MINORMASK ((1U &lt;&lt; MINORBITS) - 1) /* 次设备号掩码 */#define MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS)) /* dev右移20位得到主设备号 */#define MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK)) /* 与次设备掩码与，得到次设备号 */#define MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi)) /* MKDEV 宏将主设备号左移20位，然后与次设备号相与, 得到设备号*/ 静态申请 123/* kernel/include/linux/fs.h *///int register_chrdev_region(设备号, 设备数量, 设备名称)int register_chrdev_region(dev_t from, unsigned count, const char *name); 动态申请 123/* kernel/include/linux/fs.h *///int alloc_chrdev_region(设备号（数组形式）, 次设备号可申请最小值, 设备数量, 设备名称)int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name) 字符&#x3D;&#x3D;设备&#x3D;&#x3D;的注册与注销 字符设备cdev 1234567891011/* kernel/include/linux/cdev.h */struct cdev &#123; struct kobject kobj; //内嵌的内核对象. struct module *owner; //该字符设备所在的内核模块的对象指针. const struct file_operations *ops; //该结构描述了字符设备所能实现的方法，是极为关键的一个结构体. struct list_head list; //用来将已经向内核注册的所有字符设备形成链表. dev_t dev; //字符设备的设备号，由主设备号和次设备号构成. unsigned int count; //隶属于同一主设备号的次设备号的个数.&#125;; 初始化 init 123/* kernel/include/linux/cdev.h *///void cdev_init(字符设备/结构体/对象, 操作/结构体/行为)void cdev_init(struct cdev *cdev, const struct file_operations *fops); 添加 add 123/* kernel/include/linux/cdev.h *///int cdev_add(字符设备/结构体/对象, 设备号, 设备数量)int cdev_add(struct cdev *p, dev_t dev, unsigned count) 删除 del 123/* kernel/include/linux/fs.h *///void cdev_del(字符设备/结构体/对象)void cdev_del(struct cdev *p) 字符设备的&#x3D;&#x3D;操作&#x3D;&#x3D; 文件操作集 file_operations 12345678/* kernel/include/linux/cdev.h */static struct file_operations cdev_fops_test = &#123; .owner = THIS_MODULE, //将 owner 字段指向本模块，可以避免在模块的操作正在被使用时卸载该模块 .open = chrdev_open, //将 open 字段指向 chrdev_open(...)函数 .read = chrdev_read, //将 read 字段指向 chrdev_read(...)函数 .write = chrdev_write, //将 write 字段指向 chrdev_write(...)函数 .release = chrdev_release, //将 release 字段指向 chrdev_release(...)函数&#125;; //定义 file_operations 结构体类型的变量 cdev_test_ops 操作函数（为应用层操作函数提供接口） 12345678910111213141516171819202122static int chrdev_open(struct inode *inode, struct file *file)&#123; printk(&quot;This is chrdev_open \\n&quot;); return 0;&#125;static ssize_t chrdev_read(struct file *file,char __user *buf, size_t size, loff_t *off)&#123; printk(&quot;This is chrdev_read \\n&quot;); return 0;&#125;static ssize_t chrdev_write(struct file *file,const char __user *buf,size_t size,loff_t *off)&#123; printk(&quot;This is chrdev_write \\n&quot;); return 0;&#125;static int chrdev_release(struct inode *inode, struct file *file)&#123; return 0;&#125; 设备节点 节点创建 手动创建 123# mknod 节点名称 设备类型 主设备号 从设备号# mknod NAME TYPE MAJOR MINORmknod /dev/device_test c 234 0 自动创建 123/* kernel/include/linux/device/class.h *///class_create(节点/结构体/类, 节点名称)#define class_create(owner, name) (&#123;static struct lock_class_key __key; __class_create(owner, name, &amp;__key);&#125;) 节点销毁 销毁 123/* kernel/include/linux/device/class.h *///void class_destroy(节点/结构体/类)void class_destroy(struct class *cls); 设备与节点 设备：字符设备、块设备、网络设备 节点：类 关联 设备创建 123/* kernel/include/linux/device.h *///device_create(节点/结构体/类, 该设备的父设备或NULL, 设备号, 被添加到该设备回调的数据或NULL, 设备节点名称)device_create( (struct class *cls, struct device *parent, dev_t devt,void *drvdata, const char *fmt); 设备销毁 123/* kernel/include/linux/device.h *///device_create(节点/结构体/类, 设备号)void device_destroy(struct class *cls, dev_t devt); 模板记住 字符驱动（记住顺序） 1234567891011121314151617/* 头文件 *//* 1.定义字符设备结构体变量-对象 *//* 2.定义设备号-家庭住址/唯一标识ID *//* 3.定义file_operations结构体类型变量-操作 *//* 1.定义设备节点-类 *//* 4.实现file_operations中的操作函数集-请在3之前声明/放在3之前 *//* 5.模块加载 *//* 5.模块卸载 *//* 参数传入（可选） *//* 符号导出（可选） *//* 开源协议（可选） *//* 作者信息（可选） */ 杂项驱动 固定主设备号10 无需设置设备节点","categories":[],"tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://jianghe-jnhe.github.io/tags/Linux%E9%A9%B1%E5%8A%A8/"}]},{"title":"001-驱动基础","slug":"DriveBasis","date":"2024-09-23T11:30:00.000Z","updated":"2024-09-24T00:24:12.939Z","comments":true,"path":"2024/09/23/DriveBasis/","permalink":"https://jianghe-jnhe.github.io/2024/09/23/DriveBasis/","excerpt":"","text":"基本概念 Linux kernel 由linus等维护Linux的人员开发的内核 https://www.kernel.org/ 例如：linux-5.10.7.tar.gz linux_sdk.tar.gz 由芯片原厂（例如：Rockchip）BSP开发人员基于 Linux kernel 开发，提供给Linux驱动开发人员。 泰山派rk3566的linux sdk: tspi_linux_sdk_repo_20240131.tar.gz 是由立创开发人员写的（类似上面的BSP开发人员） Linux driver Linux驱动开发：在有Linux sdk的基础上进行开发，根据项目需求，决定增、删、改、调哪些外设，为应用开发人员提供驱动接口。 当前学习的内容 准备工作 设备与环境 个人笔记本电脑：Windows 10；gitee；mingw64；北京迅为电子开发板rk3568资料；移动WiFi（192.168.0.3） Ubuntu Linux 20.4：VSCode；make；aarch64-none-linux-gnu；gitee；USB直连移动WiFi（192.168.42.133） Linux开发板：泰山派；gitee；移动WiFi（192.168.0.196） Ubuntu Linux 20.4编译官方提供的linux_sdk.tar.gz（官方指：瑞芯微或嘉立创） 个人存放路径/jnheCode/tspkfb/kernel 交叉编译器环境配置 1sudo vi /etc/profile 123# 末尾添加# export PATH=$PATH:/usr/local/你的交叉编译器/binexport PATH=$PATH:/usr/local/gcc-arm-10.3-2021.07-x86_64-aarch64-none-linux-gnu/bin 模板记住 驱动模板（全文默写） 12345678/* 头文件 *//* 参数传入（可选） *//* 符号导出（可选） *//* 函数 *//* 模块加载 *//* 模块卸载 *//* 开源协议（可选） *//* 作者信息（可选） */ 123456789101112131415161718192021222324/* 头文件 */#include &lt;linux/init.h&gt;#include &lt;linux/kernel.h&gt;#include &lt;linux/module.h&gt;/* 参数传入（可选） *//* 符号导出（可选） *//* 函数 */static int helloworld_init(void)&#123; printk(&quot;helloworld_init\\r\\n&quot;); return 0;&#125;static void helloworld_exit(void)&#123; printk(&quot;helloworld_exit\\r\\n&quot;);&#125;/* 模块加载 */module_init(helloworld_init);/* 模块卸载 */module_exit(helloworld_exit);/* 开源协议（可选） */MODULE_LICENSE(&quot;GPL v2&quot;)/* 作者信息（可选） */MODULE_AUTHOR(&quot;jianghe&quot;) Makefile模板（全文默写） 123# 架构 交叉编译器# 目标 内核路径等# make和make clean 123456789101112# 架构 交叉编译器ARCH = arm64CROSS_COMPILE = aarch64-none-linux-gnu-# 目标 内核路径等obj-m += helloworld.oKDIR := /jnheCode/tspkfb/kernelPWD ?= $(shell pwd)# make和make cleanall: make -C $(KDIR) M=$(PWD) modulesclean: make -C $(KDIR) M=$(PWD) clean 加载与导出 123insmod helloworld.kolsmodrmmod helloworld.ko 参数传入（记住思路） 123/* 定义数据类型 *//* 参数传入函数(重点) *//* 同:驱动模板 */ 布尔型 布尔反值 字符指针 char * 短整型 无符号短整型 整型 无符号整型 长整型 无符号长整型 bool inbool charp short ushort int uint long ulong 12345678910/*- kernel/include/linux/moduleparam.h -*/#include &lt;linux/module.h&gt;/* * name：模块参数的名称 * type：模块参数的数据类型 * perm：模块参数的访问权限 */module_param(name, type, perm) module_param_array(name, type, nump, perm)module_param_string(name, string, len, perm) 12345678910/*- kernel//include/linux/stat.h -*/#define S_IRUSR 00400 /*文件所有者可读*/#define S_IWUSR 00200 /*文件所有者可写*/#define S_IXUSR 00100 /*文件所有者可执行*/#define S_IRGRP 00040 /*与文件所有者同组的用户可读*/#define S_IWGRP 00020 /*与文件所有者同组的用户可写*/#define S_IXGRP 00010 /*与文件所有者同组的用户可执行*/#define S_IROTH 00004 /*与文件所有者不同组的用户可读*/#define S_IWOTH 00002 /*与文件所有者不同组的用户可写*/#define S_IXOTH 00001 /*与文件所有者不同组的用户可可执行*/ 1234# insmod helloworld.ko 参数名=参数值insmod parameter.ko number=100 name=&quot;topeet&quot; para=0,1,2,3,4,5,6,7 str=&quot;itop&quot;lsmodrmmod helloworld.ko 符号导出（记住思路） 123456789//----------------------------/*- kernel/include/linux/export.h -*/#include &lt;linux/module.h&gt;/* 定义数据类型和函数 *//* 导出数据类型和函数 *//* 同:驱动模板 *///----------------------------/* 导入（extern）数据类型和函数 *//* 同:驱动模板 */ 12345678910111213141516//-----------------------/* 定义数据类型和函数 */int num = 10;int add(int a, int b)&#123; return (a+b);&#125;/* 导出数据类型和函数 */EXPORT_SYMBOL(num);EXPORT_SYMBOL(add);/* 同:驱动模板 *///----------------------------/* 导入（extern）数据类型和函数 */extern int num;extern int add(int a, int b);/* 同:驱动模板 */ 12# 加载：先依赖后模块# 卸载：先模块后依赖 ​","categories":[],"tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://jianghe-jnhe.github.io/tags/Linux%E9%A9%B1%E5%8A%A8/"}]},{"title":"TTL RS232 RS485","slug":"TTL-RS232-RS485","date":"2024-09-04T08:30:56.000Z","updated":"2024-10-04T13:02:06.186Z","comments":true,"path":"2024/09/04/TTL-RS232-RS485/","permalink":"https://jianghe-jnhe.github.io/2024/09/04/TTL-RS232-RS485/","excerpt":"","text":"TTL、RS232和RS485是三种不同的串行通信标准。 表格辨析 TTL RS232 RS485 数据接线 TXDRXD TXDRXDCTSRTS A+B- 逻辑电平 1：+2到+5V0：0V &#x3D;&#x3D;1：-3到-15&#x3D;&#x3D;&#x3D;&#x3D;0：+3到+15&#x3D;&#x3D; &#x3D;&#x3D;1：-2到-6&#x3D;&#x3D;&#x3D;&#x3D;0：+2到+6&#x3D;&#x3D; 通信方式 全双工 全双工 &#x3D;&#x3D;半双工&#x3D;&#x3D; 通信数量 点对点 点对点 &#x3D;&#x3D;多点&#x3D;&#x3D; 抗干扰性 差 强 很强（&#x3D;&#x3D;差分信号&#x3D;&#x3D;） 通信距离 较短，通常在1米以内 一般不超过20m 可达几十米到上千米 通信速率 取决于具体应用，可高速 最高19.2Kbps 最高10Mbps 应用场景 嵌入式系统内部通信 计算机、调制解调器、打印机等 工业自动化、智能楼宇等 TTL逻辑电平： 逻辑0：输出低电平&lt;0.4V, 输入低电平&lt;&#x3D;0.8V； 逻辑1：输出高电平&gt;2.4V,输入高电平&gt;&#x3D;2.0V。 TTL转RS232 TTL转RS485 原理 5分钟看懂!串口RS232 RS485最本质的区别！ @爱上半导体","categories":[],"tags":[]},{"title":"串口收发","slug":"SerialNote","date":"2024-09-04T08:26:56.000Z","updated":"2024-10-04T12:59:21.085Z","comments":true,"path":"2024/09/04/SerialNote/","permalink":"https://jianghe-jnhe.github.io/2024/09/04/SerialNote/","excerpt":"","text":"接收单字节数据前期准备 标准库：用户已经配置好串口的时钟、引脚（MSP层）和UART参数设置，已经配置串口中断； HAL库：使用CubeMX或CubeIDE已经配置好串口的时钟、引脚（MSP层）和UART参数设置，已经配置串口中断； 1234567891011/* 标准库 能够接收1个字节的数据 */uint8_t my_rx_data; //定义串口接收的数据变量void USART1_IRQHandler(void)&#123; if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET) &#123; my_rx_data = USART_ReceiveData(USART1); USART_ClearITPendingBit(USART1, USART_IT_RXNE); &#125;&#125; 12345678910111213141516171819202122/* HAL库 能够接收1个字节的数据 *///main.cuint8_t my_rx_data; //定义串口接收的数据变量int main(void)&#123; HAL_UART_Receive_IT(&amp;huart1,&amp;my_rx_data,1); while(1) &#123; &#125;&#125;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; if(huart == &amp;huart1) &#123; //接收数据 HAL_UART_Receive_IT(&amp;huart1, &amp;my_rx_data, 1); &#125;&#125; 推荐教程 标准库串口收发教程·江协科技 https://www.bilibili.com/video/BV1th411z7sn?p=27 HAL库串口收发教程·keysking https://www.bilibili.com/video/BV1bc411J7Tv/ 接收多个数据 定义一个固定长度的全局数组或字符串； 定义一个用于记录接收数据长度的变量，初试为0，接收累加； 标准库-WIFI为例12345/* .h文件 */#define ESP01S_RX_BUF_MAX_LEN 1024 extern char esp01s_rx_buf[];extern uint16_t esp01s_rx_buf_len;extern uint8_t esp01s_rx_data; 1234567891011121314151617181920/* .c文件 */char esp01s_rx_buf[ ESP01S_RX_BUF_MAX_LEN ];uint16_t esp01s_rx_buf_len = 0;uint8_t esp01s_rx_data;void USART1_IRQHandler(void)&#123; if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET) &#123; esp01s_rx_data = USART_ReceiveData(USART1); if( esp01s_rx_buf_len &lt; (ESP01S_RX_BUF_MAX_LEN-1) ) &#123; esp01s_rx_buf[esp01s_rx_buf_len] = esp01s_rx_data; esp01s_rx_buf_len++; &#125; USART_ClearITPendingBit(USART1, USART_IT_RXNE); &#125;&#125; HAL库-SCPI为例1234#define EL_RX_BUF_MAX_LEN 1024extern char el_rx_buf[];extern uint16_t el_rx_buf_len;extern uint8_t el_rx_data; 1HAL_UART_Receive_IT(&amp;huart1,&amp;el_rx_data,1); 123456789101112131415161718char el_rx_buf[EL_RX_BUF_MAX_LEN];uint16_t el_rx_buf_len = 0;uint8_t el_rx_data = 0;void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)&#123; if(huart == &amp;huart1) &#123; //接收电子负载的数据 if( el_rx_buf_len &lt; (EL_RX_BUF_MAX_LEN-1) ) &#123; //接收到1个数据，存入 el_rx_buf[el_rx_buf_len] = el_rx_data; el_rx_buf_len++; &#125; HAL_UART_Receive_IT(&amp;huart1, &amp;el_rx_data, 1); &#125;&#125; 以上逻辑同样适用于其他数据接收 接收整个对象 前提：接收的内容格式是制定好的。 按照制定的协议，定义全局结构体，结构体成员为各部分数据； 帧头 模式 长度 数据 CRC 帧尾 0xAA 0x01 | 0x02 0x03 X Y Z 模式+长度+数据 0xFE 123456789101112131415161718#define FRAME_HEAD 0xAA#defien FRAME_TAIL 0xFE// 定义全局结构体typedef struct &#123; uint8_t mode; uint8_t data_len; uint16_t X_axis; uint16_t Y_axis; uint16_t Z_axis; uint8_t CRC_8;&#125; GetData;// 声明全局变量extern GetData g_Get_Data;uint8_t Calculate_CRC8(uint8_t *pData, uint8_t Size);int get_data_from_uart(uint8_t uart_data, uint16_t data_len); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192uint8_t uart1_rx_data; //定义串口接收的数据变量void USART1_IRQHandler(void)&#123; static uint8_t RxState = 0; //定义表示当前状态机状态的静态变量 static int err; if (USART_GetITStatus(USART1, USART_IT_RXNE) == SET) &#123; uart1_rx_data = USART_ReceiveData(USART1); /*当前状态为0，接收数据包包头*/ if (RxState == 0) &#123; if (RxData == FRAME_HEAD) //如果数据确实是包头 &#123; RxState = 1; //置下一个状态 uart1_rx_buf_len = 0; //数据包的位置归零 &#125; &#125; /*当前状态为1，接收数据包数据*/ else if (RxState == 1) &#123; //这里接收全部数据 uart1_rx_buf[uart1_rx_buf_len] = uart1_rx_data; //将数据存入数据包数组的指定位置 uart1_rx_buf_len ++; //数据包的位置自增 if (uart1_rx_buf_len &gt;= 1 + 1 + uart1_rx_buf[1] + 1) &#123; RxState = 2; //置下一个状态 &#125; &#125; /*当前状态为2，接收数据包包尾*/ else if (RxState == 2) &#123; if (uart1_rx_data == FRAME_TAIL) //如果数据确实是包尾部 &#123; //数组中接收完成,放入结构体 err = get_data_from_uart(uart1_rx_buf, uart1_rx_buf_len); if(err) &#123; //CRC错误 &#125; else &#123; RxState = 0; //状态归0 Serial_RxFlag = 1; //接收数据包标志位置1，成功接收一个数据包 &#125; &#125; &#125; USART_ClearITPendingBit(USART1, USART_IT_RXNE); &#125;&#125;int get_data_from_uart(uint8_t uart_data, uint16_t data_len)&#123; g_Get_Data.mode = uart_data[0]; g_Get_Data.data_len = uart_data[1];// g_Get_Data.X_axis = uart_data[2] uart_data[3];// g_Get_Data.Y_axis = uart_data[4] uart_data[5];// g_Get_Data.Z_axis = uart_data[6] uart_data[7]; g_Get_Data.CRC_8 = Calculate_CRC8(uart_data,data_len-1); if( g_Get_Data.CRC_8^uart_data[data_len-1]) &#123; return 1;//err &#125; return 0;&#125;uint8_t Calculate_CRC8(uint8_t *pData, uint8_t Size)&#123; unsigned char i; unsigned char rCRC = 0; unsigned char CRC_8_POLYNOMIAL = 0x29; while(Size--) &#123; rCRC ^= *pData++; for(i=8; i&gt;0; --i) &#123; if(rCRC &amp; 0x80) &#123; rCRC = (rCRC &lt;&lt; 1) ^ CRC_8_POLYNOMIAL; &#125;else &#123; rCRC =(rCRC &lt;&lt; 1); &#125; &#125; &#125; return(rCRC);&#125;","categories":[],"tags":[]},{"title":"新年目标","slug":"myGoal","date":"2023-12-31T16:00:00.000Z","updated":"2024-09-04T08:28:47.329Z","comments":true,"path":"2024/01/01/myGoal/","permalink":"https://jianghe-jnhe.github.io/2024/01/01/myGoal/","excerpt":"","text":"当前阶段 课程 通过所有课程考试，顺利毕业即可 加权平均达到75分，不追求奖学金 技能 单片机学习与实践 ARM学习与实践 OS学习与实践 完成相关工作 做笔记写博客 证书 CET-6 健康 每周五晚跑步","categories":[],"tags":[]},{"title":"主控芯片","slug":"myMCU","date":"2023-12-31T08:45:56.000Z","updated":"2023-12-31T09:13:10.571Z","comments":true,"path":"2023/12/31/myMCU/","permalink":"https://jianghe-jnhe.github.io/2023/12/31/myMCU/","excerpt":"","text":"中心 STM32F103C8T6 72MHz，20k，64k，48pin ARM Cortex-M3 STM32F103C8T6最小系统板 低端 低功耗 STM32F030C8T6 48MHz，8k，64k，48pin ARM Cortex-M0 APM32F030C8T6 48MHz，8k，64k，48pin 极海半导体 实习项目 高端 高主频 STM32F427ZGT6 240MHz，256k，1M，144pin ARM Cortex-M4 GD32F450ZGT6 180Mhz，256k，1M，144pin ARM Cortex-M4 兆易创新 梁山派 HC32F460JEUA 200MHz，192k，512k，48pin ARM Cortex-M4 小华半导体 实验室项目 架构 RISC-V CH32V307VCT6 144MHz，64k，256k，100pin 沁恒微电子 青稞RISC-V通用型开发板 ESP32 WiFi+BlueTooth 智能家居 ESP8266 WiFi 智能家居 IDE Eclipse VSCode Linux makefile（非IDE）","categories":[],"tags":[]},{"title":"资料指南","slug":"Whoami","date":"2023-12-10T02:09:22.000Z","updated":"2024-03-24T06:34:52.125Z","comments":true,"path":"2023/12/10/Whoami/","permalink":"https://jianghe-jnhe.github.io/2023/12/10/Whoami/","excerpt":"","text":"学习经历2019级本科生：通信工程 2021年09月，通过网上找资料和修改引脚完成课程设计：《基于51单片机的倒车雷达系统设计》，制作视频教程与演示视频，上传B站。 2022年02月，在倒车雷达基础上，增加蓝牙遥控小车。制作视频教程、演示视频及资料分享，详见视频简介处，视频已上传B站。 2022年05月，通信工程综合实训，学习《基于ESP8266的物联网智能家居控制》软件开发。 2022年06月，参考网上开源项目，完成《基于ESP8266的太空人时钟小电视》，软硬件及模型已全部免费分享。 2022年11月，基本完成本科毕业设计，《机械臂定点坐标控制系统设计》，参考资料与来源均在B站视频简介处标明。 2023年01月，毕业设计:《机械臂定点坐标控制》全部资料分享出来，资料使用指南视频已上传B站，Gitee开源链接详见视频简介处。 2023年05月，Gitee使用指南。以如何下载倒车雷达资料为例讲解。 2023年05月，机械臂完整教程已上传B站。 2023年07月，考研已结束，实习已结束，大学已毕业，开始商业合作接单。 2023级研究生：仪器科学与技术 2023年09月，第一次尝试与公司商业合作：讲述自己入门单片机的经历，并为其公司推广产品。 2023年10月，开始一边学习一边在实验室打螺丝。 2023年10月，完成接单：《基于STM32的智能衣架控制系统设计》。 2023年11月，完成接单：《基于STM32的智能语音控制系统设计》。 2023年12月，完成接单：《基于STM32的热控制搅拌杯系统设计》。 2024年03月，完成接单：《基于STM32的遥控机械臂控制系统设计》。 20xx年xx月，持续更新ing。 免费资料个人说明本人之前也是小白，什么都不懂，关于51的视频中有一些理解错的地方，请大家主动学习、自主思考，这样才能学到知识；如果不想思考，直接用我的板子就可以了，资料已经很详细并全部分享到Gitee了，没有必要加我要资料；只有需要我帮你做的，可以B站@姜河jnhe私信我，获取联系方式。 关于STM32的机械臂，其实没啥亮点和实际意义，很多算法其实也都有现成的库调用，而我自己写的代码很垃圾，对单片机的理解也不深入，所以大家仅作学习了解；如果仅是需要资料，认真读一下资料获取指南，免费下载用，不用找我要资料。我目前不打算走这个方向，所以不会维护和深入学习。 关于ESP8266的学习资料，我没有分享出来，原因：1.资料过大，且可以在网上找得到；2.开发方式不是Arduion，而是在Windows下使用eclipse，参考ESP8266 SDK开发的，配置很麻烦。我其实不懂，只是跟着技新课堂的视频教程改内容，接入物联网云平台，就算分享给大家，大家也用不了。 其他没有分享出来的，一般是因为那不是我的代码而且我不懂，例如51开发板驱动PCA9685控制机械臂，它来自51黑电子。 资料列表 Gitee下载资料教程 【视频版】https://www.bilibili.com/video/BV1xg4y1j7yb 【文字版】https://www.cnblogs.com/jianghe414/p/17367884.html 《基于51单片机的倒车雷达系统设计》 https://gitee.com/jianghe2022/astern-radar_v2.0 【Gitee下载，全部资料且详细】 https://pan.baidu.com/s/13pzx1tSyKKvMlToUTtk5yQ?pwd=hphu 【网盘下载，未来可能会被清理，下同】 《基于51单片机的蓝牙遥控小车设计》 https://pan.baidu.com/s/1ZiIHiyQp0tu6oA9e6seHmA?pwd=5akx 《基于ESP8266的太空人时钟小电视》 https://pan.baidu.com/s/1qcza0wGSEP7XAkdA8VbwXg?pwd=wcxb 《基于STM32的机械臂定点坐标控制系统设计》 https://gitee.com/jianghe2022/arm-rot_v0.1 商业接单主营业务 单片机毕设、课设软硬件功能实现，论文免费指导； 为公司或企业实现项目功能； 为公司产品做推广视频、科普视频等。 联系方式 B站@姜河jnhe，通过私信方式，加联系方式详谈 https://space.bilibili.com/496375938 随便唠唠RTOS买块成本可接受的开发板，跟着网上的教程学。 LinuxWindows电脑安装虚拟机，虚拟机中安装Linux Ubuntu，Ubuntu中安装QEMU，模拟Linux开发板，不花钱跟着网上的教程学。 免费博客依托Gitee或Github，安装一些前端的工具和HEXO，免费搭建一个属于自己的技术博客，记录和复习自己学的内容，打造自己的名片。","categories":[],"tags":[]},{"title":"初见博客","slug":"hello-world","date":"2023-12-04T05:40:39.955Z","updated":"2023-12-04T06:37:48.971Z","comments":true,"path":"2023/12/04/hello-world/","permalink":"https://jianghe-jnhe.github.io/2023/12/04/hello-world/","excerpt":"","text":"欢迎来到 Hexo！这是你的第一篇文章。查看文档了解更多信息。如果你在使用Hexo时遇到任何问题，你可以在故障排除中找到答案，或者你可以在GitHub上问我。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. 快速入门 Quick Start创建一个新帖 Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing 运行网站服务 Run server1$ hexo server More info: Server 生成静态博客 Generate static files1$ hexo generate More info: Generating 部署到远程站点 Deploy to remote sites1$ hexo deploy More info: Deployment 参考教程文字版·基于Hexo的博客搭建：https://www.cnblogs.com/huanhao/p/hexobase.html视频版·基于Hexo的博客搭建：https://www.bilibili.com/video/BV1cW411A7Jx/","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"QT","slug":"QT","permalink":"https://jianghe-jnhe.github.io/tags/QT/"},{"name":"C","slug":"C","permalink":"https://jianghe-jnhe.github.io/tags/C/"},{"name":"操作系统","slug":"操作系统","permalink":"https://jianghe-jnhe.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://jianghe-jnhe.github.io/tags/Linux%E9%A9%B1%E5%8A%A8/"}]}